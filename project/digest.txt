Directory structure:
‚îî‚îÄ‚îÄ almandine-go/
    ‚îú‚îÄ‚îÄ README.md
    ‚îú‚îÄ‚îÄ LICENSE
    ‚îú‚îÄ‚îÄ devenv.lock
    ‚îú‚îÄ‚îÄ devenv.nix
    ‚îú‚îÄ‚îÄ devenv.yaml
    ‚îú‚îÄ‚îÄ go.mod
    ‚îú‚îÄ‚îÄ go.sum
    ‚îú‚îÄ‚îÄ install.ps1
    ‚îú‚îÄ‚îÄ install.sh
    ‚îú‚îÄ‚îÄ .envrc
    ‚îú‚îÄ‚îÄ .pre-commit-config.yaml
    ‚îú‚îÄ‚îÄ cmd/
    ‚îÇ   ‚îî‚îÄ‚îÄ almd/
    ‚îÇ       ‚îî‚îÄ‚îÄ main.go
    ‚îú‚îÄ‚îÄ internal/
    ‚îÇ   ‚îú‚îÄ‚îÄ cli/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ add/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ add.go
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ add_test.go
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ initcmd/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ initcmd.go
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ initcmd_test.go
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ install/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ install.go
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ install_test.go
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ list/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ list.go
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ list_test.go
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ remove/
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ remove.go
    ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ remove_test.go
    ‚îÇ   ‚îî‚îÄ‚îÄ core/
    ‚îÇ       ‚îú‚îÄ‚îÄ config/
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ config.go
    ‚îÇ       ‚îú‚îÄ‚îÄ downloader/
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ downloader.go
    ‚îÇ       ‚îú‚îÄ‚îÄ hasher/
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ hasher.go
    ‚îÇ       ‚îú‚îÄ‚îÄ lockfile/
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ lockfile.go
    ‚îÇ       ‚îú‚îÄ‚îÄ project/
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ project.go
    ‚îÇ       ‚îî‚îÄ‚îÄ source/
    ‚îÇ           ‚îú‚îÄ‚îÄ github_api.go
    ‚îÇ           ‚îî‚îÄ‚îÄ source.go
    ‚îú‚îÄ‚îÄ project/
    ‚îÇ   ‚îú‚îÄ‚îÄ PRD.md
    ‚îÇ   ‚îî‚îÄ‚îÄ TASKS.md
    ‚îú‚îÄ‚îÄ .cursor/
    ‚îú‚îÄ‚îÄ .github/
    ‚îÇ   ‚îú‚îÄ‚îÄ copilot-instructions.md
    ‚îÇ   ‚îú‚îÄ‚îÄ dependabot.yml
    ‚îÇ   ‚îî‚îÄ‚îÄ workflows/
    ‚îÇ       ‚îú‚îÄ‚îÄ ci.yml
    ‚îÇ       ‚îú‚îÄ‚îÄ release.yml
    ‚îÇ       ‚îî‚îÄ‚îÄ scorecard.yml
    ‚îî‚îÄ‚îÄ .roo/

================================================
File: README.md
================================================
# Almandine ‚Äì Lua Package Manager üíé

![License](https://img.shields.io/github/license/nightconcept/almandine-go)
![GitHub Actions Workflow Status](https://img.shields.io/github/actions/workflow/status/nightconcept/almandine-go/ci.yml)
[![Coverage Status](https://coveralls.io/repos/github/nightconcept/almandine-go/badge.svg)](https://coveralls.io/github/nightconcept/almandine-go)
![GitHub last commit](https://img.shields.io/github/last-commit/nightconcept/almandine-go)
[![OpenSSF Scorecard](https://api.scorecard.dev/projects/github.com/nightconcept/almandine-go/badge)](https://scorecard.dev/viewer/?uri=github.com/nightconcept/almandine-go)

A modern, cross-platform, developer-friendly package manager for Lua projects.
Easily manage, install, and update Lua single-file dependencies with a single CLI: `almd`.

---

## ‚ú® Features

- üì¶ **Easy Dependency Management**: Add, remove, and update Lua single-file dependencies with simple commands.
- üîí **Reproducible Installs**: Lockfiles ensure consistent environments across machines.
- üèóÔ∏è **Project Initialization**: Scaffold new Lua projects with best practices.
- üõ†Ô∏è **Cross-Platform**: Works on Linux, macOS, and Windows.

---

## Requirements

### macOS/Linux
- [Nix](https://nixos.org/)
- [devenv](https://devenv.sh/)

### Windows
- Go 1.23+
- [pre-commit](https://pre-commit.com/)
- [xc](https://github.com/joerdav/xc) task runner

_Note: These can all be installed via Scoop._

---

## üõ†Ô∏è Usage

```sh
almd init                # Create a new Lua project
almd add <package>       # Add a dependency
almd remove <package>    # Remove a dependency
almd update              # Update dependencies
almd list                # List installed dependencies
```

---

## Tasks

### lint

Run linters.

```sh
golangci-lint run
```

### build

Builds the `almd` binary.

```sh
go build -o build/almd ./cmd/almd
go build -o build/almd.exe ./cmd/almd
```

### test

Run tests.

```sh
go test ./...
```


### ready

Prepare for commit.

```sh
gitingest -o project/digest.txt -e *.toml,*.txt,.roo/*,.cursor/*,build/ .
gofmt -l -w .
go vet ./...
go mod tidy -v
golangci-lint run --fix
```

### yolo

Yolo install the `almd` binary to Windows.

```sh
go build -o build/almd ./cmd/almd
go build -o build/almd.exe ./cmd/almd
pwsh.exe -ExecutionPolicy Bypass -File ./install.ps1 --local
```

---

## License

This project is licensed under the MIT License. See [LICENSE](LICENSE) for details.



================================================
File: LICENSE
================================================
MIT License

Copyright (c) 2025 Danny Solivan

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
File: devenv.lock
================================================
{
  "nodes": {
    "devenv": {
      "locked": {
        "dir": "src/modules",
        "lastModified": 1746423062,
        "owner": "cachix",
        "repo": "devenv",
        "rev": "aba5cf8412827fdb637fceb2c305d10fcea907c6",
        "type": "github"
      },
      "original": {
        "dir": "src/modules",
        "owner": "cachix",
        "repo": "devenv",
        "type": "github"
      }
    },
    "flake-compat": {
      "flake": false,
      "locked": {
        "lastModified": 1733328505,
        "owner": "edolstra",
        "repo": "flake-compat",
        "rev": "ff81ac966bb2cae68946d5ed5fc4994f96d0ffec",
        "type": "github"
      },
      "original": {
        "owner": "edolstra",
        "repo": "flake-compat",
        "type": "github"
      }
    },
    "git-hooks": {
      "inputs": {
        "flake-compat": "flake-compat",
        "gitignore": "gitignore",
        "nixpkgs": [
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1742649964,
        "owner": "cachix",
        "repo": "git-hooks.nix",
        "rev": "dcf5072734cb576d2b0c59b2ac44f5050b5eac82",
        "type": "github"
      },
      "original": {
        "owner": "cachix",
        "repo": "git-hooks.nix",
        "type": "github"
      }
    },
    "gitignore": {
      "inputs": {
        "nixpkgs": [
          "git-hooks",
          "nixpkgs"
        ]
      },
      "locked": {
        "lastModified": 1709087332,
        "owner": "hercules-ci",
        "repo": "gitignore.nix",
        "rev": "637db329424fd7e46cf4185293b9cc8c88c95394",
        "type": "github"
      },
      "original": {
        "owner": "hercules-ci",
        "repo": "gitignore.nix",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1745934659,
        "owner": "cachix",
        "repo": "devenv-nixpkgs",
        "rev": "fbc071e5c11e23fba50037de37268e3d8a1858eb",
        "type": "github"
      },
      "original": {
        "owner": "cachix",
        "ref": "rolling",
        "repo": "devenv-nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "devenv": "devenv",
        "git-hooks": "git-hooks",
        "nixpkgs": "nixpkgs",
        "pre-commit-hooks": [
          "git-hooks"
        ]
      }
    }
  },
  "root": "root",
  "version": 7
}



================================================
File: devenv.nix
================================================
{ pkgs, inputs, ... }:

let
  xc = pkgs.buildGoModule rec {
    pname = "xc";
    version = "v0.8.5";
    subPackages = ["cmd/xc"];
    src = pkgs.fetchFromGitHub {
      owner = "joerdav";
      repo = "xc";
      rev = version;
      sha256 = "sha256-eaFHK7VsfLSgSJehv4urxq8qMPT+zzs2tRypz4q+MLc=";
    };
    vendorHash = "sha256-EbIuktQ2rExa2DawyCamTrKRC1yXXMleRB8/pcKFY5c=";
  };
in
{
  packages = with pkgs; [
    golangci-lint
    pre-commit
    xc
  ];

  languages.go = {
    enable = true;
  };

  enterShell = ''
    # Ensure pre-commit hook is installed/updated on direnv/devenv entry
    if [ -d .git ]; then
      pre-commit install --install-hooks --overwrite || true
    fi
  '';
}


================================================
File: devenv.yaml
================================================
# yaml-language-server: $schema=https://devenv.sh/devenv.schema.json
inputs:
  nixpkgs:
    url: github:cachix/devenv-nixpkgs/rolling

# If you're using non-OSS software, you can set allowUnfree to true.
# allowUnfree: true

# If you're willing to use a package that's vulnerable
# permittedInsecurePackages:
#  - "openssl-1.1.1w"

# If you have more than one devenv you can merge them
#imports:
# - ./backend



================================================
File: go.mod
================================================
module github.com/nightconcept/almandine-go

go 1.23

require (
	github.com/BurntSushi/toml v1.5.0
	github.com/fatih/color v1.18.0
	github.com/stretchr/testify v1.10.0
	github.com/urfave/cli/v2 v2.27.6
)

require (
	github.com/cpuguy83/go-md2man/v2 v2.0.5 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/russross/blackfriday/v2 v2.1.0 // indirect
	github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 // indirect
	golang.org/x/sys v0.25.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)



================================================
File: go.sum
================================================
github.com/BurntSushi/toml v1.5.0 h1:W5quZX/G/csjUnuI8SUYlsHs9M38FC7znL0lIO+DvMg=
github.com/BurntSushi/toml v1.5.0/go.mod h1:ukJfTF/6rtPPRCnwkur4qwRxa8vTRFBF0uk2lLoLwho=
github.com/cpuguy83/go-md2man/v2 v2.0.5 h1:ZtcqGrnekaHpVLArFSe4HK5DoKx1T0rq2DwVB0alcyc=
github.com/cpuguy83/go-md2man/v2 v2.0.5/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/fatih/color v1.18.0 h1:S8gINlzdQ840/4pfAwic/ZE0djQEH3wM94VfqLTZcOM=
github.com/fatih/color v1.18.0/go.mod h1:4FelSpRwEGDpQ12mAdzqdOukCy4u8WUtOY6lkT/6HfU=
github.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=
github.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=
github.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/russross/blackfriday/v2 v2.1.0 h1:JIOH55/0cWyOuilr9/qlrm0BSXldqnqwMsf35Ld67mk=
github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/urfave/cli/v2 v2.27.6 h1:VdRdS98FNhKZ8/Az8B7MTyGQmpIr36O1EHybx/LaZ4g=
github.com/urfave/cli/v2 v2.27.6/go.mod h1:3Sevf16NykTbInEnD0yKkjDAeZDS0A6bzhBH5hrMvTQ=
github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 h1:gEOO8jv9F4OT7lGCjxCBTO/36wtF6j2nSip77qHd4x4=
github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1/go.mod h1:Ohn+xnUBiLI6FVj/9LpzZWtj1/D6lUovWYBkxHVV3aM=
golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.25.0 h1:r+8e+loiHxRqhXVl6ML1nO3l1+oFoWbnlu2Ehimmi34=
golang.org/x/sys v0.25.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=



================================================
File: install.ps1
================================================
# Installer script for almd on Windows (PowerShell)
# Fetches and installs almd CLI from the latest (or specified) GitHub release, or locally with -local

$Repo = "nightconcept/almandine"
$AppHome = "$env:USERPROFILE\.almd"
$WrapperDir = "$env:LOCALAPPDATA\Programs\almd"
$TmpDir = [System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), [System.Guid]::NewGuid().ToString())
$Version = $null
$LocalMode = $false

# Usage: install.ps1 [-local] [version]
foreach ($arg in $args) {
  if ($arg -eq '--local') {
    $LocalMode = $true
  } elseif (-not $Version) {
    $Version = $arg
  }
}

function Download($url, $dest) {
  if (Get-Command Invoke-WebRequest -ErrorAction SilentlyContinue) {
    Invoke-WebRequest -Uri $url -OutFile $dest -UseBasicParsing
  } elseif (Get-Command curl.exe -ErrorAction SilentlyContinue) {
    curl.exe -L $url -o $dest
  } elseif (Get-Command wget.exe -ErrorAction SilentlyContinue) {
    wget.exe $url -O $dest
  } else {
    Write-Error "Neither Invoke-WebRequest, curl, nor wget found. Please install one and re-run."
    exit 1
  }
}

function GithubApi($url) {
  if (Get-Command Invoke-RestMethod -ErrorAction SilentlyContinue) {
    return Invoke-RestMethod -Uri $url -UseBasicParsing
  } elseif (Get-Command curl.exe -ErrorAction SilentlyContinue) {
    $json = curl.exe -s $url
    return $json | ConvertFrom-Json
  } elseif (Get-Command wget.exe -ErrorAction SilentlyContinue) {
    $json = wget.exe -qO- $url
    return $json | ConvertFrom-Json
  } else {
    Write-Error "Neither Invoke-RestMethod, curl, nor wget found. Please install one and re-run."
    exit 1
  }
}

if ($LocalMode) {
  Write-Host "[DEV] Installing from local repository ..."
  New-Item -ItemType Directory -Path $AppHome -Force | Out-Null
  New-Item -ItemType Directory -Path $WrapperDir -Force | Out-Null
  Copy-Item -Path ./build/almd.exe -Destination (Join-Path $WrapperDir 'almd.exe') -Force
  Write-Host "\n[DEV] Local installation complete!"
  Write-Host "Make sure $WrapperDir is in your Path environment variable. You may need to restart your terminal or system."
  exit 0
}

if (!(Test-Path $TmpDir)) { New-Item -ItemType Directory -Path $TmpDir | Out-Null }

# Fetch latest tag from GitHub if version not specified
if ($Version) {
  $Tag = $Version
} else {
  Write-Host "Fetching Almandine version info ..."
  $TagsApiUrl = "https://api.github.com/repos/$Repo/tags?per_page=1"
  $Tags = GithubApi $TagsApiUrl
  if ($Tags -is [System.Array] -and $Tags.Count -gt 0) {
    $Tag = $Tags[0].name
  } elseif ($Tags.name) {
    $Tag = $Tags.name
  } else {
    Write-Error "Could not determine latest tag from GitHub."
    exit 1
  }
}

$ArchiveUrl = "https://github.com/$Repo/archive/refs/tags/$Tag.zip"
$ArchiveName = "$Repo-$Tag.zip" -replace "/", "-"

Write-Host "Downloading Almandine archive for tag $Tag ..."
$ZipPath = Join-Path $TmpDir $ArchiveName
Download $ArchiveUrl $ZipPath

Write-Host "Extracting Almandine ..."
Add-Type -AssemblyName System.IO.Compression.FileSystem
[System.IO.Compression.ZipFile]::ExtractToDirectory($ZipPath, $TmpDir)

# Find extracted folder (name format: almandine-<tag>)
$ExtractedDir = Join-Path $TmpDir "almandine-$Tag"
if (!(Test-Path $ExtractedDir)) {
  # Try with v prefix (e.g., v0.1.0)
  $ExtractedDir = Join-Path $TmpDir "almandine-v$Tag"
  if (!(Test-Path $ExtractedDir)) {
    Write-Error "Could not find extracted directory for tag $Tag."
    exit 1
  }
}

Write-Host "Installing Almandine ..."
# Check for previous install and warn if present
if (Test-Path $AppHome) {
  Write-Host ""
  Write-Host "‚ö†Ô∏è  WARNING: Previous Almandine install detected at $AppHome. It will be OVERWRITTEN! ‚ö†Ô∏è" -ForegroundColor Yellow
  Write-Host ""
}
New-Item -ItemType Directory -Path $AppHome -Force | Out-Null
New-Item -ItemType Directory -Path $WrapperDir -Force | Out-Null

# Copy the binary to the wrapper directory
Copy-Item -Path (Join-Path $ExtractedDir 'almd.exe') -Destination (Join-Path $WrapperDir 'almd.exe') -Force

Write-Host "\nInstallation complete!"
Write-Host "Make sure $WrapperDir is in your Path environment variable. You may need to restart your terminal or system."

Remove-Item -Recurse -Force $TmpDir



================================================
File: install.sh
================================================
#!/bin/sh
# Installer script for almd on Linux/macOS
# Fetches and installs almd from GitHub Releases, or locally with --local
# Requires: curl or wget, unzip, (jq optional for best experience)
set -e

REPO="nightconcept/almandine"
APP_HOME="$HOME/.almd"
PRIMARY_WRAPPER_DIR="/usr/local/bin"
FALLBACK_WRAPPER_DIR="$HOME/.local/bin"
WRAPPER_DIR=""
TMP_DIR="$(mktemp -d)"
VERSION=""
LOCAL_MODE=0

# Determine install location: /usr/local/bin (preferred), $HOME/.local/bin (fallback)
if [ -w "$PRIMARY_WRAPPER_DIR" ]; then
  WRAPPER_DIR="$PRIMARY_WRAPPER_DIR"
else
  WRAPPER_DIR="$FALLBACK_WRAPPER_DIR"
fi

# Usage: install.sh [--local] [version]
while [ $# -gt 0 ]; do
  case "$1" in
    --local)
      LOCAL_MODE=1
      ;;
    *)
      VERSION="$1"
      ;;
  esac
  shift
done

# Helper: download file (curl or wget)
download() {
  url="$1"
  dest="$2"
  if command -v curl >/dev/null 2>&1; then
    curl -L --fail --retry 3 -o "$dest" "$url"
  elif command -v wget >/dev/null 2>&1; then
    wget -O "$dest" "$url"
  else
    printf '%s\n' "Error: Neither curl nor wget found. Please install one and re-run." >&2
    exit 1
  fi
}

if [ "$LOCAL_MODE" -eq 1 ]; then
  printf '%s\n' "[DEV] Installing local almd binary..."
  mkdir -p "$APP_HOME" # Keep for potential app config/data

  # Ensure WRAPPER_DIR exists and copy the local binary 'almd' to it
  mkdir -p "$WRAPPER_DIR"
  cp ./build/almd "$WRAPPER_DIR/almd" # Use the 'almd' binary from the project root
  chmod +x "$WRAPPER_DIR/almd"

  printf '\n[DEV] Local almd binary installation complete!\n'
  printf 'Make sure %s is in your PATH. You may need to restart your shell.\n' "$WRAPPER_DIR"
  exit 0
fi

# Determine tag to install
if [ -n "$VERSION" ]; then
  TAG="$VERSION"
else
  printf '%s\n' "Fetching latest tag ..."
  TAG=$(curl -sL "https://api.github.com/repos/$REPO/tags?per_page=1" | \
    grep '"name"' | head -n1 | sed -E 's/ *\"name\": *\"([^\"]+)\".*/\1/')
  if [ -z "$TAG" ]; then
    printf '%s\n' "Error: Could not determine latest tag from GitHub." >&2
    exit 1
  fi
fi

ARCHIVE_URL="https://github.com/$REPO/archive/refs/tags/$TAG.zip"
ARCHIVE_NAME="$(echo "$REPO-$TAG.zip" | tr '/' '-')"

printf '%s\n' "Downloading archive for tag $TAG ..."
download "$ARCHIVE_URL" "$TMP_DIR/$ARCHIVE_NAME"

printf '%s\n' "Extracting CLI ..."
unzip -q -o "$TMP_DIR/$ARCHIVE_NAME" -d "$TMP_DIR"

# Find extracted folder (name format: almandine-<tag> or almandine-v<tag>)
EXTRACTED_DIR="$TMP_DIR/almandine-$TAG"
if [ ! -d "$EXTRACTED_DIR" ]; then
  EXTRACTED_DIR="$TMP_DIR/almandine-v$TAG"
  if [ ! -d "$EXTRACTED_DIR" ]; then
    printf '%s\n' "Error: Could not find extracted directory for tag $TAG." >&2
    exit 1
  fi
fi

printf '%s\n' "Installing CLI to $APP_HOME ..."
mkdir -p "$APP_HOME"
cp -r "$EXTRACTED_DIR/src" "$APP_HOME/"

printf '%s\n' "Installing wrapper script to $WRAPPER_DIR ..."
mkdir -p "$WRAPPER_DIR"
cp "$EXTRACTED_DIR/install/almd" "$WRAPPER_DIR/almd"
chmod +x "$WRAPPER_DIR/almd"

printf '\nInstallation complete!\n'
printf 'Make sure %s is in your PATH. You may need to restart your shell.\n' "$WRAPPER_DIR"

# Check if $WRAPPER_DIR is in PATH, recommend adding if missing
case ":$PATH:" in
  *:"$WRAPPER_DIR":*)
    # Already in PATH, nothing to do
    ;;
  *)
    printf '\n[INFO] %s is not in your PATH.\n' "$WRAPPER_DIR"
    if [ "$WRAPPER_DIR" = "$PRIMARY_WRAPPER_DIR" ]; then
      printf 'You may want to add it to your PATH or check your shell configuration.\n'
    else
      printf 'To add it, run (for bash):\n  echo ''export PATH="$HOME/.local/bin:$PATH"'' >> ~/.bashrc && source ~/.bashrc\n'
      printf 'Or for zsh:\n  echo ''export PATH="$HOME/.local/bin:$PATH"'' >> ~/.zshrc && source ~/.zshrc\n'
      printf 'Then restart your terminal or run ''exec $SHELL'' to reload your PATH.\n'
    fi
    ;;
esac

rm -rf "$TMP_DIR"



================================================
File: .envrc
================================================
export DIRENV_WARN_TIMEOUT=20s

eval "$(devenv direnvrc)"

# The use_devenv function supports passing flags to the devenv command
# For example: use devenv --impure --option services.postgres.enable:bool true
use devenv



================================================
File: .pre-commit-config.yaml
================================================
# Top-level pre-commit config for Go project
repos:
  - repo: local
    hooks:
      - id: gofmt
        name: gofmt
        entry: gofmt -l -w
        language: golang
        types: [go]
      - id: go-vet
        name: go vet
        entry: go vet ./...
        language: golang
        types: [go]
        pass_filenames: false
      - id: go-mod-tidy
        name: go mod tidy
        entry: go mod tidy -v
        language: golang
        types: [go]
        files: ^go\.(mod|sum)$
        pass_filenames: false
        always_run: true
      - id: golangci-lint
        name: golangci-lint
        entry: golangci-lint run --fix
        language: system
        types: [go]
        pass_filenames: false



================================================
File: cmd/almd/main.go
================================================
// Title: Almandine CLI Application Entry Point
// Purpose: Initializes and runs the Almandine command-line interface application,
// defining its commands and default behavior.
package main

// Import the "fmt" package, which provides functions for formatted I/O
// (like printing to the console).
import (
	"log"
	"os"

	"github.com/urfave/cli/v2"

	"github.com/nightconcept/almandine-go/internal/cli/add"
	"github.com/nightconcept/almandine-go/internal/cli/initcmd"
	"github.com/nightconcept/almandine-go/internal/cli/install" // Changed from update to install
	"github.com/nightconcept/almandine-go/internal/cli/list"
	"github.com/nightconcept/almandine-go/internal/cli/remove"
)

// The main function, where the program execution begins.
func main() {
	app := &cli.App{
		Name:    "almd",
		Usage:   "A simple project manager for single-file dependencies",
		Version: "v0.0.1", // Placeholder version
		Action: func(c *cli.Context) error {
			// Default action if no command is specified
			_ = cli.ShowAppHelp(c)
			return nil
		},
		Commands: []*cli.Command{
			initcmd.GetInitCommand(),
			add.AddCommand,
			remove.RemoveCommand(),
			install.NewInstallCommand(), // Changed from update.NewUpdateCommand()
			list.ListCmd,
		},
	}

	if err := app.Run(os.Args); err != nil {
		log.Fatal(err)
	}
}



================================================
File: internal/cli/add/add.go
================================================
// Title: Almandine CLI Add Command
// Purpose: Implements the 'add' command for the Almandine CLI, which downloads
// a specified dependency, saves it to the project, and updates project
// configuration and lock files.
package add

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/nightconcept/almandine-go/internal/core/config"
	"github.com/nightconcept/almandine-go/internal/core/downloader"
	"github.com/nightconcept/almandine-go/internal/core/hasher"
	"github.com/nightconcept/almandine-go/internal/core/lockfile"
	"github.com/nightconcept/almandine-go/internal/core/project"
	"github.com/nightconcept/almandine-go/internal/core/source"
	"github.com/urfave/cli/v2"
)

// Helper function to get filename without extension
func getFileNameWithoutExtension(fileName string) string {
	return strings.TrimSuffix(fileName, filepath.Ext(fileName))
}

// Helper function to get file extension
func getFileExtension(fileName string) string {
	return filepath.Ext(fileName)
}

// AddCommand defines the structure for the "add" command.
var AddCommand = &cli.Command{
	Name:      "add",
	Usage:     "Downloads a dependency and adds it to the project",
	ArgsUsage: "<source_url>",
	Flags: []cli.Flag{
		&cli.StringFlag{
			Name:    "directory",
			Aliases: []string{"d"},
			Usage:   "Specify the target directory for the dependency",
			Value:   "src/lib/",
		},
		&cli.StringFlag{
			Name:    "name",
			Aliases: []string{"n"},
			Usage:   "Specify the name for the dependency (defaults to filename from URL)",
		},
		&cli.BoolFlag{
			Name:  "verbose",
			Usage: "Enable verbose output",
		},
	},
	Action: func(cCtx *cli.Context) (err error) { // MODIFIED: Named return error
		sourceURLInput := ""
		if cCtx.NArg() > 0 {
			sourceURLInput = cCtx.Args().Get(0) // .First() is equivalent but .Get(0) is more explicit
		} else {
			err = cli.Exit("Error: <source_url> argument is required.", 1) // MODIFIED
			return
		}

		targetDir := cCtx.String("directory")
		customName := cCtx.String("name")
		verbose := cCtx.Bool("verbose")

		if verbose {
			fmt.Printf("Attempting to add dependency:\n")
			fmt.Printf("  Source URL Input: %s\n", sourceURLInput)
			fmt.Printf("  Target Directory: %s\n", targetDir)
			fmt.Printf("  Custom Name (from -n flag): '[%s]'\n", customName)
			fmt.Printf("  Verbose Output: %t\n", verbose)
		}

		// Task 2.2: Parse the source URL
		var parsedInfo *source.ParsedSourceInfo
		parsedInfo, err = source.ParseSourceURL(sourceURLInput) // Assign to named return 'err'
		if err != nil {
			err = cli.Exit(fmt.Sprintf("Error parsing source URL '%s': %v", sourceURLInput, err), 1) // MODIFIED
			return
		}

		if verbose {
			fmt.Printf("Parsed Source Info:\n")
			fmt.Printf("  Raw Download URL: %s\n", parsedInfo.RawURL)
			fmt.Printf("  Canonical URL for Manifest: %s\n", parsedInfo.CanonicalURL)
			fmt.Printf("  Extracted Ref (commit/branch/tag): %s\n", parsedInfo.Ref)
			fmt.Printf("  Suggested Filename from URL: %s\n", parsedInfo.SuggestedFilename)
		}

		// Task 2.3: Download the file using the RawURL
		if verbose {
			fmt.Printf("Downloading from %s...\n", parsedInfo.RawURL)
		}
		var fileContent []byte
		fileContent, err = downloader.DownloadFile(parsedInfo.RawURL) // Assign to named return 'err'
		if err != nil {
			err = cli.Exit(fmt.Sprintf("Error downloading file from '%s': %v", parsedInfo.RawURL, err), 1) // MODIFIED
			return
		}
		if verbose {
			fmt.Printf("Downloaded %d bytes successfully.\n", len(fileContent))
		}

		// Task 2.4: Determine target path and save file
		var dependencyNameInManifest string
		var fileNameOnDisk string

		suggestedBaseName := getFileNameWithoutExtension(parsedInfo.SuggestedFilename)
		suggestedExtension := getFileExtension(parsedInfo.SuggestedFilename)

		if customName != "" {
			dependencyNameInManifest = customName
			fileNameOnDisk = customName + suggestedExtension // Ensure extension is preserved
		} else {
			if suggestedBaseName == "" || suggestedBaseName == "." || suggestedBaseName == "/" {
				err = cli.Exit(fmt.Sprintf("Error: Could not infer a valid base filename from URL's suggested filename: '%s'. Use -n to specify a name.", parsedInfo.SuggestedFilename), 1) // MODIFIED
				return
			}
			dependencyNameInManifest = suggestedBaseName
			fileNameOnDisk = parsedInfo.SuggestedFilename
		}

		if fileNameOnDisk == "" || fileNameOnDisk == "." || fileNameOnDisk == "/" {
			err = cli.Exit("Error: Could not determine a valid final filename for saving. Inferred name was empty or invalid.", 1) // MODIFIED
			return
		}

		if verbose {
			fmt.Printf("Effective filename for saving: %s\n", fileNameOnDisk)
			fmt.Printf("Dependency name in manifest/lockfile: %s\n", dependencyNameInManifest)
		}

		// Construct the full path relative to the current directory (project root)
		projectRoot := "."
		fullPath := filepath.Join(projectRoot, targetDir, fileNameOnDisk)
		relativeDestPath := filepath.ToSlash(filepath.Join(targetDir, fileNameOnDisk))

		if verbose {
			fmt.Printf("Resolved full path for saving: %s\n", fullPath)
			fmt.Printf("Relative destination path for manifest: %s\n", relativeDestPath)
		}

		// Create the target directory if it doesn't exist
		dirToCreate := filepath.Dir(fullPath)
		if verbose {
			fmt.Printf("Ensuring directory exists: %s\n", dirToCreate)
		}
		// Use a temporary variable for MkdirAll's error to not shadow the named return 'err'
		if mkdirErr := os.MkdirAll(dirToCreate, 0755); mkdirErr != nil {
			err = cli.Exit(fmt.Sprintf("Error creating directory '%s': %v", dirToCreate, mkdirErr), 1) // MODIFIED
			return
		}

		// Save the downloaded content to the file
		// This is a critical point: if this succeeds but subsequent steps fail, we should try to clean up this file.
		if verbose {
			fmt.Printf("Saving file to %s...\n", fullPath)
		}
		// Use a temporary variable for WriteFile's error
		if writeErr := os.WriteFile(fullPath, fileContent, 0644); writeErr != nil {
			// No file to clean up yet, as it wasn't written.
			err = cli.Exit(fmt.Sprintf("Error writing file '%s': %v", fullPath, writeErr), 1) // MODIFIED
			return
		}
		// File has been written. From this point on, if an error occurs, we must attempt to clean it up.
		fileWritten := true
		defer func() {
			// 'err' here refers to the named return parameter of the Action func.
			if err != nil && fileWritten { // If an error occurred (i.e., Action is returning an error) and file was written
				if verbose {
					fmt.Printf("Attempting to clean up downloaded file '%s' due to error: %v\n", fullPath, err)
				}
				cleanupErr := os.Remove(fullPath)
				if cleanupErr != nil {
					var errWriter io.Writer = os.Stderr
					if cCtx.App != nil && cCtx.App.ErrWriter != nil {
						errWriter = cCtx.App.ErrWriter
					}
					_, _ = fmt.Fprintf(errWriter, "Warning: Failed to clean up downloaded file '%s' during error handling: %v\n", fullPath, cleanupErr)
				} else {
					if verbose {
						fmt.Printf("Successfully cleaned up downloaded file '%s'.\n", fullPath)
					}
				}
			}
		}()

		// Task 2.5: Calculate hash of the downloaded content
		var fileHashSHA256 string
		var hashErr error
		fileHashSHA256, hashErr = hasher.CalculateSHA256(fileContent)
		if hashErr != nil {
			// Assign to named return 'err'
			err = cli.Exit(fmt.Sprintf("Error calculating SHA256 hash: %v. File '%s' was saved but is now being cleaned up.", hashErr, fullPath), 1) // MODIFIED
			return
		}
		if verbose {
			fmt.Printf("SHA256 hash of downloaded file: %s\n", fileHashSHA256)
		}

		// Task 2.7: Update project.toml
		if verbose {
			fmt.Println("Updating project.toml...")
		}
		// projectTomlPath variable is no longer needed as LoadProjectToml and WriteProjectToml
		// now correctly use projectRoot to construct the path internally.
		var proj *project.Project // MODIFIED: Use pointer type
		var loadTomlErr error
		// Pass projectRoot to LoadProjectToml, not the full path to the file
		proj, loadTomlErr = config.LoadProjectToml(projectRoot)
		if loadTomlErr != nil {
			if os.IsNotExist(loadTomlErr) {
				// Construct the expected full path for a more accurate error message if needed,
				// though LoadProjectToml itself will return the error from os.ReadFile(filepath.Join(projectRoot, config.ProjectTomlName))
				expectedProjectTomlPath := filepath.Join(projectRoot, config.ProjectTomlName)
				detailedError := fmt.Errorf("project.toml not found at '%s' (no such file or directory): %w", expectedProjectTomlPath, loadTomlErr)
				err = cli.Exit(fmt.Sprintf("Error: %s. File '%s' was saved but is now being cleaned up.", detailedError, fullPath), 1)
				return
			} else {
				err = cli.Exit(fmt.Sprintf("Error loading %s: %v. File '%s' was saved but is now being cleaned up.", config.ProjectTomlName, loadTomlErr, fullPath), 1)
				return
			}
		}

		// Ensure dependencies map is initialized
		if proj.Dependencies == nil {
			proj.Dependencies = make(map[string]project.Dependency)
		}

		// For project.toml, use the canonical source identifier
		proj.Dependencies[dependencyNameInManifest] = project.Dependency{
			Source: parsedInfo.CanonicalURL,
			Path:   relativeDestPath,
		}

		// Use a temporary variable for WriteProjectToml's error
		// Pass projectRoot to WriteProjectToml, not the full path to the file
		if writeTomlErr := config.WriteProjectToml(projectRoot, proj); writeTomlErr != nil { // proj is already a pointer
			err = cli.Exit(fmt.Sprintf("Error writing %s: %v. File '%s' was saved but is now being cleaned up. %s may be in an inconsistent state.", config.ProjectTomlName, writeTomlErr, fullPath, config.ProjectTomlName), 1)
			return
		}

		if verbose {
			fmt.Printf("Successfully updated %s for dependency '%s'.\n", config.ProjectTomlName, dependencyNameInManifest)
		}

		// Task 2.8: Implement Lockfile Update
		if verbose {
			fmt.Println("Updating almd-lock.toml...")
		}

		var lf *lockfile.Lockfile // MODIFIED: Use pointer type and correct package
		var loadLockErr error
		lf, loadLockErr = lockfile.Load(projectRoot) // Load or initialize if not found
		if loadLockErr != nil {
			err = cli.Exit(fmt.Sprintf("Error loading/initializing %s: %v. File '%s' saved and %s updated, but lockfile operation failed. %s and %s may be inconsistent. Downloaded file '%s' is being cleaned up.", lockfile.LockfileName, loadLockErr, fullPath, config.ProjectTomlName, config.ProjectTomlName, lockfile.LockfileName, fullPath), 1)
			return
		}

		// Determine integrity hash: commit:<commit_hash> or sha256:<hash>
		var integrityHash string
		isLikelyCommitSHA := func(ref string) bool {
			if len(ref) != 40 { // Standard Git SHA-1 length
				return false
			}
			for _, r := range ref {
				if (r < '0' || r > '9') && (r < 'a' || r > 'f') && (r < 'A' || r > 'F') {
					return false
				}
			}
			return true
		}

		if parsedInfo.Provider == "github" && parsedInfo.Owner != "" && parsedInfo.Repo != "" && parsedInfo.PathInRepo != "" && parsedInfo.Ref != "" && !strings.HasPrefix(parsedInfo.Ref, "error:") {
			if isLikelyCommitSHA(parsedInfo.Ref) {
				if verbose {
					fmt.Printf("Using provided ref '%s' as commit SHA for lockfile hash.\\n", parsedInfo.Ref)
				}
				integrityHash = fmt.Sprintf("commit:%s", parsedInfo.Ref)
			} else {
				// Ref is likely a branch or tag, try to get the specific commit SHA
				if verbose {
					fmt.Printf("Attempting to resolve ref '%s' to a specific commit SHA for path '%s' in repo '%s/%s'...\\n", parsedInfo.Ref, parsedInfo.PathInRepo, parsedInfo.Owner, parsedInfo.Repo)
				}
				var commitSHA string
				var getCommitErr error
				commitSHA, getCommitErr = source.GetLatestCommitSHAForFile(parsedInfo.Owner, parsedInfo.Repo, parsedInfo.PathInRepo, parsedInfo.Ref)
				if getCommitErr != nil {
					if verbose {
						fmt.Printf("Warning: Failed to get specific commit SHA for '%s@%s': %v. Falling back to SHA256 content hash for lockfile.\\n", parsedInfo.PathInRepo, parsedInfo.Ref, getCommitErr)
					}
					integrityHash = fileHashSHA256
				} else {
					if verbose {
						fmt.Printf("Successfully resolved ref '%s' to commit SHA '%s'.\\n", parsedInfo.Ref, commitSHA)
					}
					integrityHash = fmt.Sprintf("commit:%s", commitSHA)
				}
			}
		} else {
			if verbose && parsedInfo.Provider == "github" {
				fmt.Printf("Insufficient information or invalid ref ('%s') to fetch specific commit SHA for GitHub source. Falling back to SHA256 content hash for lockfile.\\n", parsedInfo.Ref)
			} else if verbose {
				fmt.Printf("Source is not GitHub or ref is missing. Falling back to SHA256 content hash for lockfile.\\n")
			}
			integrityHash = fileHashSHA256 // Fallback to SHA256
		}

		// For lockfile, use the exact raw download URL and calculated integrity hash
		lf.AddOrUpdatePackage(dependencyNameInManifest, parsedInfo.RawURL, relativeDestPath, integrityHash)

		// Use a temporary variable for lockfile.Save's error
		if saveLockErr := lockfile.Save(projectRoot, lf); saveLockErr != nil {
			// Assign to named return 'err'
			err = cli.Exit(fmt.Sprintf("Error saving %s: %v. File '%s' saved and %s updated, but saving %s failed. %s and %s may be inconsistent. Downloaded file '%s' is being cleaned up.", lockfile.LockfileName, saveLockErr, fullPath, config.ProjectTomlName, lockfile.LockfileName, config.ProjectTomlName, lockfile.LockfileName, fullPath), 1) // MODIFIED
			return
		}

		if verbose {
			fmt.Printf("Successfully updated %s for dependency '%s'.\n", lockfile.LockfileName, dependencyNameInManifest)
		}

		fmt.Printf("Successfully added '%s' from '%s' to '%s'.\nUpdated %s and %s.\n", // Simplified success message
			dependencyNameInManifest, sourceURLInput, fullPath, config.ProjectTomlName, lockfile.LockfileName)

		return nil // err is nil, so defer func() will not trigger cleanup
	},
}



================================================
File: internal/cli/add/add_test.go
================================================
// Title: Almandine CLI Add Command Tests
// Purpose: Contains test cases for the 'add' command of the Almandine CLI,
// covering various scenarios including successful additions, error handling,
// and interactions with project configuration and lock files.
package add

import (
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/BurntSushi/toml"
	"github.com/nightconcept/almandine-go/internal/core/config"
	"github.com/nightconcept/almandine-go/internal/core/lockfile"
	"github.com/nightconcept/almandine-go/internal/core/project"
	"github.com/nightconcept/almandine-go/internal/core/source"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/urfave/cli/v2"
)

func init() {
	// Enable host validation bypass for testing with mock server
	source.SetTestModeBypassHostValidation(true)
}

// setupAddTestEnvironment creates a temporary directory for testing and optionally
// initializes a project.toml file within it.
// It returns the path to the temporary directory.
func setupAddTestEnvironment(t *testing.T, initialProjectTomlContent string) (tempDir string) {
	t.Helper()
	tempDir = t.TempDir()

	if initialProjectTomlContent != "" {
		projectTomlPath := filepath.Join(tempDir, config.ProjectTomlName)
		err := os.WriteFile(projectTomlPath, []byte(initialProjectTomlContent), 0644)
		require.NoError(t, err, "Failed to write initial project.toml")
	}
	return tempDir
}

// runAddCommand executes the 'add' command within a specific working directory.
// It changes the current working directory to workDir for the duration of the command execution.
// addCmdArgs should be the arguments for the 'add' command itself (e.g., URL, flags).
func runAddCommand(t *testing.T, workDir string, addCmdArgs ...string) error {
	t.Helper()

	originalWd, err := os.Getwd()
	require.NoError(t, err, "Failed to get current working directory")
	err = os.Chdir(workDir)
	require.NoError(t, err, "Failed to change to working directory: %s", workDir)
	defer func() {
		require.NoError(t, os.Chdir(originalWd), "Failed to restore original working directory")
	}()

	app := &cli.App{
		Name: "almd-test-add",
		Commands: []*cli.Command{
			AddCommand,
		},
		// Suppress help printer during tests unless specifically testing help output
		Writer:    os.Stderr, // Default, or io.Discard for cleaner test logs
		ErrWriter: os.Stderr, // Default, or io.Discard
		ExitErrHandler: func(context *cli.Context, err error) {
			// Do nothing by default, let the test assertions handle errors from app.Run()
			// This prevents os.Exit(1) from urfave/cli from stopping the test run
		},
	}

	cliArgs := []string{"almd-test-add", "add"}
	cliArgs = append(cliArgs, addCmdArgs...)

	return app.Run(cliArgs)
}

// startMockServer starts an httptest.Server that serves specific responses
// for a map of expected paths.
// Other paths will result in a 404.
func startMockServer(t *testing.T, pathResponses map[string]struct {
	Body string
	Code int
}) *httptest.Server {
	t.Helper()
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Construct path with query for matching, as GitHub API calls include queries.
		requestPathWithQuery := r.URL.Path
		if r.URL.RawQuery != "" {
			requestPathWithQuery += "?" + r.URL.RawQuery
		}

		for path, response := range pathResponses {
			// Allow simple path match or path with query match
			if r.Method == http.MethodGet && (r.URL.Path == path || requestPathWithQuery == path) {
				w.WriteHeader(response.Code)
				_, err := w.Write([]byte(response.Body))
				assert.NoError(t, err, "Mock server failed to write response body for path: %s", path)
				return
			}
		}
		t.Logf("Mock server: unexpected request: Method %s, Path %s, Query %s", r.Method, r.URL.Path, r.URL.RawQuery)
		http.NotFound(w, r)
	}))
	t.Cleanup(server.Close) // Ensure server is closed after the test
	return server
}

// readProjectToml reads and unmarshals a project.toml file into a project.Project struct.
func readProjectToml(t *testing.T, tomlPath string) project.Project {
	t.Helper()
	bytes, err := os.ReadFile(tomlPath)
	require.NoError(t, err, "Failed to read project.toml: %s", tomlPath)

	var projCfg project.Project
	err = toml.Unmarshal(bytes, &projCfg)
	require.NoError(t, err, "Failed to unmarshal project.toml: %s", tomlPath)
	return projCfg
}

// readAlmdLockToml reads and unmarshals an almd-lock.toml file into a project.LockFile struct.
func readAlmdLockToml(t *testing.T, lockPath string) project.LockFile {
	t.Helper()
	bytes, err := os.ReadFile(lockPath)
	require.NoError(t, err, "Failed to read almd-lock.toml: %s", lockPath)

	var lockCfg project.LockFile
	err = toml.Unmarshal(bytes, &lockCfg)
	require.NoError(t, err, "Failed to unmarshal almd-lock.toml: %s", lockPath)
	return lockCfg
}

func TestAddCommand_Success_ExplicitNameAndDir(t *testing.T) {
	// --- Test Setup ---
	// This test implements Task 3.4.2
	initialTomlContent := `
[package]
name = "test-project"
version = "0.1.0"
`
	tempDir := setupAddTestEnvironment(t, initialTomlContent)

	mockContent := "// This is a mock lua library content\nlocal lib = {}\nfunction lib.hello() print('hello from lua lib') end\nreturn lib\n"
	// Adjust mockServerPath to fit the expected /<owner>/<repo>/<ref>/<file...> structure
	// and use .lua extension as requested.
	mockFileURLPath := "/testowner/testrepo/v1.0.0/mylib_script.lua"
	mockCommitSHA := "fixedmockshaforexplicittest1234567890"
	// Path for the GetLatestCommitSHAForFile call (matches what GetLatestCommitSHAForFile constructs)
	mockAPIPathForCommits := fmt.Sprintf("/repos/%s/%s/commits?path=%s&sha=%s&per_page=1", "testowner", "testrepo", "mylib_script.lua", "v1.0.0")
	mockAPIResponseBody := fmt.Sprintf(`[{"sha": "%s"}]`, mockCommitSHA)

	pathResps := map[string]struct {
		Body string
		Code int
	}{
		mockFileURLPath:       {Body: mockContent, Code: http.StatusOK},
		mockAPIPathForCommits: {Body: mockAPIResponseBody, Code: http.StatusOK},
	}
	mockServer := startMockServer(t, pathResps)

	// IMPORTANT: Override GithubAPIBaseURL to point to our mock server for this test
	originalGHAPIBaseURL := source.GithubAPIBaseURL
	source.GithubAPIBaseURL = mockServer.URL
	defer func() { source.GithubAPIBaseURL = originalGHAPIBaseURL }()

	dependencyURL := mockServer.URL + mockFileURLPath
	dependencyName := "mylib"        // As per Task 3.4.2
	dependencyDir := "vendor/custom" // As per Task 3.4.2

	// --- Run Command ---
	err := runAddCommand(t, tempDir,
		"-n", dependencyName,
		"-d", dependencyDir,
		dependencyURL,
	)
	require.NoError(t, err, "almd add command failed")

	// --- Assertions ---

	// 1. Verify downloaded file content and path
	// The filename should be the explicit name + extension from source URL path,
	// based on the observed behavior of the `add` command.
	extractedSourceFileExtension := filepath.Ext(mockFileURLPath)           // .lua
	expectedFileNameOnDisk := dependencyName + extractedSourceFileExtension // mylib.lua

	downloadedFilePath := filepath.Join(tempDir, dependencyDir, expectedFileNameOnDisk)
	require.FileExists(t, downloadedFilePath, "Downloaded file does not exist at expected path: %s", downloadedFilePath)

	contentBytes, readErr := os.ReadFile(downloadedFilePath)
	require.NoError(t, readErr, "Failed to read downloaded file: %s", downloadedFilePath)
	assert.Equal(t, mockContent, string(contentBytes), "Downloaded file content mismatch")

	// 2. Verify project.toml was updated correctly
	projectTomlPath := filepath.Join(tempDir, config.ProjectTomlName)
	projCfg := readProjectToml(t, projectTomlPath)

	require.NotNil(t, projCfg.Dependencies, "Dependencies map in project.toml is nil")
	depEntry, ok := projCfg.Dependencies[dependencyName]
	require.True(t, ok, "Dependency entry not found in project.toml for: %s", dependencyName)

	// Expected canonical source based on the new mockServerPath structure
	// Format: github:<owner>/<repo>/<path_to_file_in_repo>@<ref>
	expectedCanonicalSource := "github:testowner/testrepo/mylib_script.lua@v1.0.0"
	assert.Equal(t, expectedCanonicalSource, depEntry.Source, "Dependency source mismatch in project.toml")
	assert.Equal(t, filepath.ToSlash(filepath.Join(dependencyDir, expectedFileNameOnDisk)), depEntry.Path, "Dependency path mismatch in project.toml")

	// 3. Verify almd-lock.toml was created/updated correctly
	lockFilePath := filepath.Join(tempDir, "almd-lock.toml")
	require.FileExists(t, lockFilePath, "almd-lock.toml was not created")
	lockCfg := readAlmdLockToml(t, lockFilePath)

	assert.Equal(t, "1", lockCfg.APIVersion, "API version in almd-lock.toml mismatch")
	require.NotNil(t, lockCfg.Package, "Packages map in almd-lock.toml is nil")
	lockPkgEntry, ok := lockCfg.Package[dependencyName]
	require.True(t, ok, "Package entry not found in almd-lock.toml for: %s", dependencyName)

	assert.Equal(t, dependencyURL, lockPkgEntry.Source, "Package source mismatch in almd-lock.toml (raw URL)")
	assert.Equal(t, filepath.ToSlash(filepath.Join(dependencyDir, expectedFileNameOnDisk)), lockPkgEntry.Path, "Package path mismatch in almd-lock.toml")

	// Hash should now reflect the commit SHA from the mocked API call.
	expectedHash := "commit:" + mockCommitSHA
	assert.Equal(t, expectedHash, lockPkgEntry.Hash, "Package hash mismatch in almd-lock.toml")
}

func TestAddCommand_Success_InferredName_DefaultDir(t *testing.T) {
	// --- Test Setup ---
	// This test implements Task 3.4.3
	initialTomlContent := `
[package]
name = "test-project-inferred"
version = "0.1.0"
`
	tempDir := setupAddTestEnvironment(t, initialTomlContent)

	mockContent := "// This is a mock lua library for inferred name test\nlocal lib = {}\nreturn lib\n"
	// Adjust mockServerPath to fit the expected /<owner>/<repo>/<ref>/<file...> structure
	// for the test mode URL parser.
	mockFileURLPath_Inferred := "/inferredowner/inferredrepo/mainbranch/test_dependency_file.lua"
	mockCommitSHA_Inferred := "fixedmockshaforinferredtest1234567890"
	mockAPIPathForCommits_Inferred := fmt.Sprintf("/repos/%s/%s/commits?path=%s&sha=%s&per_page=1", "inferredowner", "inferredrepo", "test_dependency_file.lua", "mainbranch")
	mockAPIResponseBody_Inferred := fmt.Sprintf(`[{"sha": "%s"}]`, mockCommitSHA_Inferred)

	pathResps_Inferred := map[string]struct {
		Body string
		Code int
	}{
		mockFileURLPath_Inferred:       {Body: mockContent, Code: http.StatusOK},
		mockAPIPathForCommits_Inferred: {Body: mockAPIResponseBody_Inferred, Code: http.StatusOK},
	}
	mockServer := startMockServer(t, pathResps_Inferred)

	// IMPORTANT: Override GithubAPIBaseURL to point to our mock server for this test
	originalGHAPIBaseURL_Inferred := source.GithubAPIBaseURL
	source.GithubAPIBaseURL = mockServer.URL
	defer func() { source.GithubAPIBaseURL = originalGHAPIBaseURL_Inferred }()

	dependencyURL := mockServer.URL + mockFileURLPath_Inferred

	// --- Run Command ---
	// No -n (name) or -d (directory) flags, testing inference and defaults
	err := runAddCommand(t, tempDir, dependencyURL)
	require.NoError(t, err, "almd add command failed")

	// --- Assertions ---

	// 1. Verify downloaded file content and path (inferred name, default directory)
	sourceFileName := filepath.Base(mockFileURLPath_Inferred)                           // "test_dependency_file.lua"
	inferredDepName := strings.TrimSuffix(sourceFileName, filepath.Ext(sourceFileName)) // "test_dependency_file"

	expectedDiskFileName := sourceFileName // "test_dependency_file.lua"
	// The add command defaults to "src/lib" when -d is not specified.
	expectedDirOnDisk := "src/lib"
	downloadedFilePath := filepath.Join(tempDir, expectedDirOnDisk, expectedDiskFileName)

	require.FileExists(t, downloadedFilePath, "Downloaded file does not exist at expected path: %s", downloadedFilePath)
	contentBytes, readErr := os.ReadFile(downloadedFilePath)
	require.NoError(t, readErr, "Failed to read downloaded file: %s", downloadedFilePath)
	assert.Equal(t, mockContent, string(contentBytes), "Downloaded file content mismatch")

	// 2. Verify project.toml was updated correctly
	projectTomlPath := filepath.Join(tempDir, config.ProjectTomlName)
	projCfg := readProjectToml(t, projectTomlPath)

	require.NotNil(t, projCfg.Dependencies, "Dependencies map in project.toml is nil")
	depEntry, ok := projCfg.Dependencies[inferredDepName]
	require.True(t, ok, "Dependency entry not found in project.toml for inferred name: %s", inferredDepName)

	// Because the mockServerPath now conforms to the /<owner>/<repo>/<ref>/<file...> structure,
	// the canonical source identifier will be a GitHub-like string.
	expectedCanonicalSource := "github:inferredowner/inferredrepo/test_dependency_file.lua@mainbranch"
	assert.Equal(t, expectedCanonicalSource, depEntry.Source, "Dependency source mismatch in project.toml")

	expectedPathInToml := filepath.ToSlash(filepath.Join(expectedDirOnDisk, expectedDiskFileName))
	assert.Equal(t, expectedPathInToml, depEntry.Path, "Dependency path mismatch in project.toml")

	// 3. Verify almd-lock.toml was created/updated correctly
	lockFilePath := filepath.Join(tempDir, "almd-lock.toml")
	require.FileExists(t, lockFilePath, "almd-lock.toml was not created")
	lockCfg := readAlmdLockToml(t, lockFilePath)

	assert.Equal(t, "1", lockCfg.APIVersion, "API version in almd-lock.toml mismatch")
	require.NotNil(t, lockCfg.Package, "Packages map in almd-lock.toml is nil")
	lockPkgEntry, ok := lockCfg.Package[inferredDepName]
	require.True(t, ok, "Package entry not found in almd-lock.toml for inferred name: %s", inferredDepName)

	assert.Equal(t, dependencyURL, lockPkgEntry.Source, "Package source mismatch in almd-lock.toml (raw URL)")
	assert.Equal(t, expectedPathInToml, lockPkgEntry.Path, "Package path mismatch in almd-lock.toml")

	// Hash should now reflect the commit SHA from the mocked API call.
	expectedHash := "commit:" + mockCommitSHA_Inferred
	assert.Equal(t, expectedHash, lockPkgEntry.Hash, "Package hash mismatch in almd-lock.toml")
}

func TestAddCommand_GithubURLWithCommitHash(t *testing.T) {
	// --- Test Setup ---
	// This test implements parts of Task 3.4.4 (specifically direct commit hash in URL)
	initialTomlContent := `
[package]
name = "test-project-commit-hash"
version = "0.1.0"
`
	tempDir := setupAddTestEnvironment(t, initialTomlContent)

	mockContent := "// Mock Lib with specific commit\nlocal lib = { info = \"version_commit123\" }\nreturn lib\n"
	// URL includes a commit hash directly
	directCommitSHA := "commitabc123def456ghi789jkl012mno345pqr"
	mockFileURLPath := fmt.Sprintf("/ghowner/ghrepo/%s/mylib.lua", directCommitSHA) // Path includes commit SHA

	// The canonical URL should also reflect this direct commit SHA if parsed correctly
	// The source.ParseSourceURL logic is what determines this.
	// If the URL is github.com/.../blob/<hash>/file, it becomes github:owner/repo/file@hash
	// If the URL is raw.githubusercontent.com/.../<hash>/file, it also becomes github:owner/repo/file@hash

	pathResps := map[string]struct {
		Body string
		Code int
	}{
		// This is the raw download URL path
		mockFileURLPath: {Body: mockContent, Code: http.StatusOK},
		// No separate GitHub API call for /commits is strictly needed here if the commit SHA is directly in the download URL
		// and source.ParseSourceURL correctly extracts it as the 'Ref' for canonical URL and for lockfile hash logic.
		// However, if the internal logic *always* tries to call GetLatestCommitSHAForFile, we might need to mock it.
		// For simplicity, let's assume direct extraction works or that GetLatestCommitSHAForFile isn't called for raw URLs with SHAs.
		// If tests fail related to API calls, this mock might need to be added:
		// mockAPIPathForCommits := fmt.Sprintf("/repos/ghowner/ghrepo/commits?path=mylib.lua&sha=%s&per_page=1", directCommitSHA)
		// pathResps[mockAPIPathForCommits] = struct{Body string; Code int}{Body: fmt.Sprintf(`[{"sha": "%s"}]`, directCommitSHA), Code: http.StatusOK}
	}
	// Correction: The GitHub API call for commits is indeed made, so we must mock it.
	mockAPIPathForCommits := fmt.Sprintf("/repos/ghowner/ghrepo/commits?path=mylib.lua&sha=%s&per_page=1", directCommitSHA)
	pathResps[mockAPIPathForCommits] = struct {
		Body string
		Code int
	}{
		Body: fmt.Sprintf(`[{"sha": "%s"}]`, directCommitSHA),
		Code: http.StatusOK,
	}
	mockServer := startMockServer(t, pathResps)

	// Override GithubAPIBaseURL and RawGithubContentURLBase to point to our mock server.
	// The source URL parser needs to recognize this as a "GitHub" URL to trigger commit hash logic.
	originalGHAPIBaseURL := source.GithubAPIBaseURL
	// originalRawGHContentURLBase := source.RawGithubContentURLBase // This variable does not exist
	source.GithubAPIBaseURL = mockServer.URL // For API calls like /commits
	// source.RawGithubContentURLBase = mockServer.URL // This variable does not exist

	defer func() {
		source.GithubAPIBaseURL = originalGHAPIBaseURL
		// source.RawGithubContentURLBase = originalRawGHContentURLBase // This variable does not exist
	}()

	// Construct a URL that our source parser will identify as a GitHub raw content URL with a commit hash.
	// When testModeBypassHostValidation is true, ParseSourceURL expects a path like /<owner>/<repo>/<ref>/<file...>
	// and u.String() (the full mock URL) becomes the RawURL for download.
	dependencyURL := mockServer.URL + mockFileURLPath // mockFileURLPath is /ghowner/ghrepo/<hash>/mylib.lua

	dependencyName := "mylibcommit"
	dependencyDir := "libs/gh"

	// --- Run Command ---
	err := runAddCommand(t, tempDir,
		"-n", dependencyName,
		"-d", dependencyDir,
		dependencyURL,
	)
	require.NoError(t, err, "almd add command failed for GitHub URL with commit hash")

	// --- Assertions ---
	expectedFileNameOnDisk := dependencyName + ".lua" // mylibcommit.lua
	downloadedFilePath := filepath.Join(tempDir, dependencyDir, expectedFileNameOnDisk)

	// 1. Verify downloaded file
	require.FileExists(t, downloadedFilePath)
	contentBytes, _ := os.ReadFile(downloadedFilePath)
	assert.Equal(t, mockContent, string(contentBytes))

	// 2. Verify project.toml
	projectTomlPath := filepath.Join(tempDir, config.ProjectTomlName)
	projCfg := readProjectToml(t, projectTomlPath)
	depEntry, ok := projCfg.Dependencies[dependencyName]
	require.True(t, ok, "Dependency entry not found in project.toml")

	// The canonical source should be github:ghowner/ghrepo/mylib.lua@commitabc...
	expectedCanonicalSource := fmt.Sprintf("github:ghowner/ghrepo/mylib.lua@%s", directCommitSHA)
	assert.Equal(t, expectedCanonicalSource, depEntry.Source)
	assert.Equal(t, filepath.ToSlash(filepath.Join(dependencyDir, expectedFileNameOnDisk)), depEntry.Path)

	// 3. Verify almd-lock.toml
	lockFilePath := filepath.Join(tempDir, "almd-lock.toml")
	require.FileExists(t, lockFilePath)
	lockCfg := readAlmdLockToml(t, lockFilePath)
	lockPkgEntry, ok := lockCfg.Package[dependencyName]
	require.True(t, ok, "Package entry not found in almd-lock.toml")

	// The source in lockfile should be the exact download URL used
	assert.Equal(t, dependencyURL, lockPkgEntry.Source)
	assert.Equal(t, filepath.ToSlash(filepath.Join(dependencyDir, expectedFileNameOnDisk)), lockPkgEntry.Path)

	// Hash should be commit:<commit_sha>
	expectedHashWithCommit := "commit:" + directCommitSHA
	assert.Equal(t, expectedHashWithCommit, lockPkgEntry.Hash, "Package hash mismatch in almd-lock.toml (direct commit hash)")
}

func TestAddCommand_DownloadFailure(t *testing.T) {
	// --- Test Setup ---
	// This test implements Task 3.4.5
	initialTomlContent := `
[package]
name = "test-project-dlfail"
version = "0.1.0"
`
	tempDir := setupAddTestEnvironment(t, initialTomlContent)

	// Mock server to return a 404 error
	mockFileURLPath := "/owner/repo/main/nonexistent.lua"
	pathResps := map[string]struct {
		Body string
		Code int
	}{
		mockFileURLPath: {Body: "File not found", Code: http.StatusNotFound},
	}
	mockServer := startMockServer(t, pathResps)
	dependencyURL := mockServer.URL + mockFileURLPath

	// --- Run Command ---
	err := runAddCommand(t, tempDir, dependencyURL)

	// --- Assertions ---
	require.Error(t, err, "almd add command should return an error on download failure")

	// Check that the error message indicates a download failure from the mock server.
	// The exact error message from downloader.DownloadFile includes the URL and the HTTP status.
	// Example: "downloading from http...: server returned HTTP status 404 Not Found"
	// For the test, we make it more specific to the mock server's intent.
	if exitErr, ok := err.(cli.ExitCoder); ok {
		assert.Contains(t, exitErr.Error(), "Error downloading file", "Error message should indicate download failure")
		assert.Contains(t, exitErr.Error(), "status code 404", "Error message should indicate 404 status")
	} else {
		assert.Fail(t, "Expected cli.ExitError for command failure")
	}

	// Verify no dependency file was created
	expectedFilePath := filepath.Join(tempDir, "src/lib/nonexistent.lua") // Default dir and inferred name
	_, statErr := os.Stat(expectedFilePath)
	assert.True(t, os.IsNotExist(statErr), "Dependency file should not have been created on download failure")

	// Verify project.toml was not modified (or created if it was somehow missing and add tried to create it before failing)
	// We assume project.toml existed as per initialTomlContent.
	projectTomlPath := filepath.Join(tempDir, config.ProjectTomlName)
	projCfg := readProjectToml(t, projectTomlPath) // This will fail if project.toml doesn't exist
	assert.Equal(t, "test-project-dlfail", projCfg.Package.Name, "project.toml package name should be unchanged")
	assert.Len(t, projCfg.Dependencies, 0, "project.toml should have no dependencies after a failed add")

	// Verify almd-lock.toml was not created
	lockFilePath := filepath.Join(tempDir, "almd-lock.toml")
	_, statErrLock := os.Stat(lockFilePath)
	assert.True(t, os.IsNotExist(statErrLock), "almd-lock.toml should not have been created on download failure")
}

func TestAddCommand_ProjectTomlNotFound(t *testing.T) {
	// --- Test Setup ---
	// This test implements Sub-Task 3.4.6
	tempDir := setupAddTestEnvironment(t, "") // Ensure no project.toml is created

	// Mock server for the URL, as the command expects a URL.
	mockContent := "// Some content"
	mockFileURLPath := "/owner/repo/main/somefile.lua"
	pathResps := map[string]struct {
		Body string
		Code int
	}{
		mockFileURLPath: {Body: mockContent, Code: http.StatusOK},
	}
	mockServer := startMockServer(t, pathResps)
	dependencyURL := mockServer.URL + mockFileURLPath

	// --- Run Command ---
	err := runAddCommand(t, tempDir, dependencyURL)

	// --- Assertions ---
	// Based on Task 3.4.6, we expect an error if project.toml is not found.
	// IMPORTANT: The current implementation of `add.go` *does not* error out if project.toml is missing;
	// it creates one in memory. This test is written against the task's explicit requirement for an error.
	// Thus, this test is expected to FAIL with the current `add.go` implementation, highlighting the discrepancy.
	require.Error(t, err, "almd add command should return an error when project.toml is not found")

	// If `add.go` were modified to error out when project.toml is missing (e.g., by not handling os.IsNotExist
	// specifically by creating a new project, but by returning an error from `config.LoadProjectToml`),
	// we would expect an error message related to that.
	if exitErr, ok := err.(cli.ExitCoder); ok {
		// This assertion will likely fail with current `add.go` as no error is returned.
		// If `add.go` is changed, this string might need adjustment.
		assert.Contains(t, exitErr.Error(), "project.toml", "Error message should indicate project.toml was not found or could not be loaded")
		assert.Contains(t, exitErr.Error(), "no such file or directory", "Error message details should reflect os.IsNotExist")
	} else {
		// This path will be taken if `err` is not nil but not a `cli.ExitError`,
		// or if `err` is nil (test fails at `require.Error`).
		assert.Fail(t, "Expected a cli.ExitError if command was to fail as per task requirements")
	}

	// Verify no dependency file was created
	expectedFilePath := filepath.Join(tempDir, "src/lib/somefile.lua") // Default dir and inferred name
	_, statErr := os.Stat(expectedFilePath)
	assert.True(t, os.IsNotExist(statErr), "Dependency file should not have been created if project.toml is missing and command errored")

	// Verify almd-lock.toml was not created
	lockFilePath := filepath.Join(tempDir, "almd-lock.toml")
	_, statErrLock := os.Stat(lockFilePath)
	assert.True(t, os.IsNotExist(statErrLock), "almd-lock.toml should not have been created if project.toml is missing and command errored")

	// Verify project.toml was not created by the add command (as it was the source of the supposed error)
	projectTomlPathMain := filepath.Join(tempDir, config.ProjectTomlName)
	_, statErrProject := os.Stat(projectTomlPathMain)
	assert.True(t, os.IsNotExist(statErrProject), "project.toml should not have been created by the add command if it was missing and an error was expected")
}

func TestAddCommand_CleanupOnFailure_LockfileWriteError(t *testing.T) {
	// This test implements Task 3.4.7

	// --- Test Setup ---
	initialTomlContent := `
[package]
name = "test-cleanup-project"
version = "0.1.0"
`
	tempDir := setupAddTestEnvironment(t, initialTomlContent)
	projectTomlPath := filepath.Join(tempDir, config.ProjectTomlName)

	mockContent := "// Mock library content for cleanup test\\nlocal m = {}\\nfunction m.do() return 'ok' end\\nreturn m"

	// Adjusted mockFileURLPath to conform to the test mode parser's expected GitHub-like format
	mockOwner := "testowner"
	mockRepo := "testrepo"
	mockRef := "main"
	mockFileName := "mocklib.lua"
	mockFileURLPath := fmt.Sprintf("/%s/%s/%s/%s", mockOwner, mockRepo, mockRef, mockFileName)

	mockCommitSHA := "mockcleanupcommitsha1234567890"
	// Mock for GitHub API call to get commit SHA
	mockAPIPathForCommits := fmt.Sprintf("/repos/%s/%s/commits?path=%s&sha=%s&per_page=1", mockOwner, mockRepo, mockFileName, mockRef)
	mockAPIResponseBody := fmt.Sprintf(`[{"sha": "%s"}]`, mockCommitSHA)

	pathResps := map[string]struct {
		Body string
		Code int
	}{
		mockFileURLPath:       {Body: mockContent, Code: http.StatusOK},
		mockAPIPathForCommits: {Body: mockAPIResponseBody, Code: http.StatusOK}, // Added mock for commit API
	}
	mockServer := startMockServer(t, pathResps)

	// IMPORTANT: Override GithubAPIBaseURL to point to our mock server for this test to ensure commit API mock is hit.
	// This was seen in other tests in internal/cli/add/add_test.go
	originalGHAPIBaseURL := source.GithubAPIBaseURL
	source.GithubAPIBaseURL = mockServer.URL
	defer func() { source.GithubAPIBaseURL = originalGHAPIBaseURL }()

	dependencyURL := mockServer.URL + mockFileURLPath

	sourceFileName := mockFileName // Use the defined mockFileName
	expectedDepName := strings.TrimSuffix(sourceFileName, filepath.Ext(sourceFileName))
	defaultLibsDir := "src/lib"
	expectedDownloadedFilePath := filepath.Join(tempDir, defaultLibsDir, sourceFileName)

	lockFilePath := filepath.Join(tempDir, lockfile.LockfileName)
	err := os.Mkdir(lockFilePath, 0755)
	require.NoError(t, err, "Test setup: Failed to create %s as a directory", lockfile.LockfileName)

	// --- Run Command ---
	cmdErr := runAddCommand(t, tempDir, dependencyURL)

	// --- Assertions ---
	require.Error(t, cmdErr, "almd add command should return an error due to lockfile write failure")

	if exitErr, ok := cmdErr.(cli.ExitCoder); ok {
		errorOutput := strings.ToLower(exitErr.Error())
		assert.Contains(t, errorOutput, "lockfile", "Error message should mention 'lockfile'")
		assert.Contains(t, errorOutput, lockfile.LockfileName, "Error message should mention the lockfile name")
		// Check for OS-specific parts of the error like "is a directory" or a TOML encoding error for the lockfile
		// This makes the test more robust if the exact wording changes slightly.
		assert.Condition(t, func() bool {
			return strings.Contains(errorOutput, "is a directory") ||
				strings.Contains(errorOutput, "toml") || // If TOML marshal fails due to directory
				strings.Contains(errorOutput, "permission denied") // Another possible OS error
		}, "Error message details should indicate a write/type issue with the lockfile path: %s", errorOutput)
	} else {
		// Handle cases where the error might not be a cli.ExitCoder but a direct error
		// (though urfave/cli usually wraps errors in ExitCoder for command actions).
		lowerCmdErr := strings.ToLower(cmdErr.Error())
		assert.Contains(t, lowerCmdErr, "lockfile", "Direct error message should mention 'lockfile': %v", cmdErr)
		assert.Fail(t, "Expected command error to be a cli.ExitCoder, got %T: %v", cmdErr, cmdErr)
	}

	_, statErr := os.Stat(expectedDownloadedFilePath)
	assert.True(t, os.IsNotExist(statErr),
		"Downloaded dependency file '%s' should have been removed after lockfile write failure.", expectedDownloadedFilePath)

	projCfg := readProjectToml(t, projectTomlPath)
	depEntry, ok := projCfg.Dependencies[expectedDepName]
	require.True(t, ok, "Dependency '%s' should still be listed in project.toml. Current dependencies: %v", expectedDepName, projCfg.Dependencies)

	// The canonical source will now be a GitHub-like source string
	expectedCanonicalSource := fmt.Sprintf("github:%s/%s/%s@%s", mockOwner, mockRepo, mockFileName, mockRef)
	assert.Equal(t, expectedCanonicalSource, depEntry.Source, "Dependency source in project.toml for '%s' is incorrect", expectedDepName)
	assert.Equal(t, filepath.ToSlash(filepath.Join(defaultLibsDir, sourceFileName)), depEntry.Path,
		"Dependency path in project.toml is incorrect for '%s'", expectedDepName)

	lockFileStat, statLockErr := os.Stat(lockFilePath)
	require.NoError(t, statLockErr, "Should be able to stat the %s path (which is a directory)", lockfile.LockfileName)
	assert.True(t, lockFileStat.IsDir(), "%s should remain a directory", lockfile.LockfileName)

	_, err = os.ReadFile(lockFilePath)
	require.Error(t, err, "Attempting to read %s (which is a dir) as a file should fail", lockfile.LockfileName)
}



================================================
File: internal/cli/initcmd/initcmd.go
================================================
package initcmd

import (
	"bufio"
	"fmt"
	"os"
	"strings"

	"github.com/nightconcept/almandine-go/internal/core/config"
	"github.com/nightconcept/almandine-go/internal/core/project"
	"github.com/urfave/cli/v2"
)

// Helper function to prompt user and get input with a default value
func promptWithDefault(reader *bufio.Reader, promptText string, defaultValue string) (string, error) {
	// Show default if not empty
	if defaultValue != "" {
		fmt.Printf("%s (default: %s): ", promptText, defaultValue)
	} else {
		fmt.Printf("%s: ", promptText)
	}

	input, err := reader.ReadString('\n')
	if err != nil {
		// Return specific error for prompt context
		return "", fmt.Errorf("failed to read input for '%s': %w", promptText, err)
	}
	input = strings.TrimSpace(input)
	if input == "" {
		return defaultValue, nil // Return default if input is empty
	}
	return input, nil
}

// GetInitCommand returns the definition for the "init" command.
func GetInitCommand() *cli.Command {
	return &cli.Command{
		Name:  "init",
		Usage: "Initialize a new Almandine project (creates project.toml)",
		Action: func(c *cli.Context) error {
			fmt.Println("Starting project initialization...")

			reader := bufio.NewReader(os.Stdin)

			var packageName, version, license, description string
			var err error

			// Prompt for package name
			packageName, err = promptWithDefault(reader, "Package name", "my-almandine-project")
			if err != nil {
				return cli.Exit(err.Error(), 1)
			}

			// Prompt for version
			version, err = promptWithDefault(reader, "Version", "0.1.0")
			if err != nil {
				return cli.Exit(err.Error(), 1)
			}

			// Prompt for license
			license, err = promptWithDefault(reader, "License", "MIT")
			if err != nil {
				return cli.Exit(err.Error(), 1)
			}

			// Prompt for description (optional, default is empty)
			description, err = promptWithDefault(reader, "Description (optional)", "")
			if err != nil {
				return cli.Exit(err.Error(), 1)
			}

			fmt.Println("\n--- Collected Metadata ---")
			fmt.Printf("Package Name: %s\n", packageName)
			fmt.Printf("Version:      %s\n", version)
			fmt.Printf("License:      %s\n", license)
			fmt.Printf("Description:  %s\n", description)
			fmt.Println("--------------------------")

			// --- Task 1.3: Implement Interactive Prompts for Scripts ---
			scripts := make(map[string]string)
			fmt.Println("\nEnter scripts (leave script name empty to finish):")

			for {
				scriptName, errLFSN := promptWithDefault(reader, "Script name", "") // Renamed err to avoid conflict
				if errLFSN != nil {
					return cli.Exit(fmt.Sprintf("Error reading script name: %v", errLFSN), 1)
				}

				if scriptName == "" {
					break
				}

				scriptCmd, errLFSC := promptWithDefault(reader, fmt.Sprintf("Command for script '%s'", scriptName), "") // Renamed err
				if errLFSC != nil {
					return cli.Exit(fmt.Sprintf("Error reading command for script '%s': %v", scriptName, errLFSC), 1)
				}
				scripts[scriptName] = scriptCmd
			}

			if _, exists := scripts["run"]; !exists {
				scripts["run"] = "lua src/main.lua"
			}

			fmt.Println("-------------------------")

			// --- Task 1.4: Implement Interactive Prompts for Dependencies (Placeholders) ---
			dependencies := make(map[string]string)
			fmt.Println("\nEnter dependencies (leave dependency name empty to finish):")

			for {
				depName, errLFDN := promptWithDefault(reader, "Dependency name", "") // Renamed err
				if errLFDN != nil {
					return cli.Exit(fmt.Sprintf("Error reading dependency name: %v", errLFDN), 1)
				}

				if depName == "" {
					break
				}

				depSource, errLFDS := promptWithDefault(reader, fmt.Sprintf("Source/Version for dependency '%s'", depName), "") // Renamed err
				if errLFDS != nil {
					return cli.Exit(fmt.Sprintf("Error reading source for dependency '%s': %v", depName, errLFDS), 1)
				}
				dependencies[depName] = depSource
			}

			fmt.Println("\n--- Collected Dependencies ---")
			if len(dependencies) > 0 {
				for name, source := range dependencies {
					fmt.Printf("%s = \"%s\"\n", name, source)
				}
			} else {
				fmt.Println("(No dependencies defined)")
			}
			fmt.Println("----------------------------")

			// Transform collected placeholder dependencies into the correct structure
			projectDependencies := make(map[string]project.Dependency)
			for name, source := range dependencies {
				projectDependencies[name] = project.Dependency{
					Source: source, // The collected placeholder string
					Path:   "",     // Path is not determined at init for placeholders
				}
			}

			// Populate the project structure
			projectData := project.Project{
				Package: &project.PackageInfo{
					Name:        packageName,
					Version:     version,
					License:     license,
					Description: description,
				},
				Scripts:      scripts,
				Dependencies: projectDependencies, // Use the transformed map
			}

			// Write to project.toml using the centralized function
			// Pass "." for current directory, as WriteProjectToml expects a directory path.
			err = config.WriteProjectToml(".", &projectData)
			if err != nil {
				return cli.Exit(fmt.Sprintf("Error writing project.toml: %v", err), 1)
			}

			fmt.Println("\nSuccessfully initialized project and wrote project.toml.")
			return nil
		},
	}
}



================================================
File: internal/cli/initcmd/initcmd_test.go
================================================
// Package commands_test contains tests for the commands package.
package initcmd

import (
	"bytes"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/BurntSushi/toml"
	"github.com/nightconcept/almandine-go/internal/core/project"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/urfave/cli/v2"
)

// Helper function to simulate user input for prompts
func simulateInput(inputs []string) (*os.File, *os.File, error) {
	r, w, err := os.Pipe()
	if err != nil {
		return nil, nil, err
	}
	// Write all inputs separated by newlines
	inputString := strings.Join(inputs, "\n") + "\n"
	_, err = w.WriteString(inputString)
	if err != nil {
		_ = r.Close()
		_ = w.Close()
		return nil, nil, err
	}
	_ = w.Close() // Close writer to signal EOF for reader
	return r, w, nil
}

// Helper function to capture stdout
func captureOutput() (*os.File, *os.File, *bytes.Buffer, error) {
	r, w, err := os.Pipe()
	if err != nil {
		return nil, nil, nil, err
	}
	var buf bytes.Buffer
	// Use a MultiWriter to capture stdout and also print it if needed for debugging
	_, _ = w.Write([]byte{})
	return r, w, &buf, nil
}

func TestInitCommand(t *testing.T) {
	// --- Test Setup ---
	tempDir, err := os.MkdirTemp("", "almandine_init_test")
	require.NoError(t, err, "Failed to create temporary directory")
	defer func() { _ = os.RemoveAll(tempDir) }() // Clean up afterwards

	originalWd, err := os.Getwd()
	require.NoError(t, err, "Failed to get current working directory")
	err = os.Chdir(tempDir)
	require.NoError(t, err, "Failed to change to temporary directory")
	defer func() { _ = os.Chdir(originalWd) }() // Change back

	// Prepare simulated user input (simulate pressing Enter for defaults where applicable)
	// Order: name, version, license, description, script name, script cmd, empty script name, dep name, dep src, empty dep name
	simulatedInputs := []string{
		"test-project",         // Package name
		"1.2.3",                // Version
		"Apache-2.0",           // License
		"A test project",       // Description
		"",                     // Empty script name (finish scripts)
		"my-dep",               // Dependency name 1
		"github.com/user/repo", // Dependency source 1
		"",                     // Empty dependency name (finish dependencies)
	}

	// Redirect Stdin
	oldStdin := os.Stdin
	rStdin, _, err := simulateInput(simulatedInputs)
	require.NoError(t, err, "Failed to simulate stdin")
	os.Stdin = rStdin
	defer func() { os.Stdin = oldStdin; _ = rStdin.Close() }() // Restore Stdin

	// Capture Stdout (optional, but can be useful for debugging output)
	oldStdout := os.Stdout
	rStdout, wStdout, _, err := captureOutput()
	require.NoError(t, err, "Failed to capture stdout")
	os.Stdout = wStdout
	defer func() { os.Stdout = oldStdout; _ = wStdout.Close(); _ = rStdout.Close() }() // Restore Stdout

	// --- Run Command ---
	app := &cli.App{
		Name: "almandine-test",
		Commands: []*cli.Command{
			GetInitCommand(),
		},
	}

	runErr := app.Run([]string{"almandine-test", "init"})

	// --- Assertions ---
	assert.NoError(t, runErr, "Init command returned an error")

	// Check if project.toml was created
	tomlPath := filepath.Join(tempDir, "project.toml")
	_, err = os.Stat(tomlPath)
	require.NoError(t, err, "project.toml was not created")

	// Read and parse the created project.toml
	tomlBytes, err := os.ReadFile(tomlPath)
	require.NoError(t, err, "Failed to read project.toml")

	var generatedConfig project.Project
	err = toml.Unmarshal(tomlBytes, &generatedConfig)
	require.NoError(t, err, "Failed to unmarshal project.toml")

	// Verify Package Metadata
	assert.Equal(t, "test-project", generatedConfig.Package.Name, "Package name mismatch")
	assert.Equal(t, "1.2.3", generatedConfig.Package.Version, "Version mismatch")
	assert.Equal(t, "Apache-2.0", generatedConfig.Package.License, "License mismatch")
	assert.Equal(t, "A test project", generatedConfig.Package.Description, "Description mismatch")

	// Verify Scripts (should include the default 'run' and the provided 'build')
	expectedScripts := map[string]string{
		"run": "lua src/main.lua",
	}
	assert.Equal(t, expectedScripts, generatedConfig.Scripts, "Scripts mismatch")

	// Verify Dependencies
	expectedDependencies := map[string]project.Dependency{
		"my-dep": {
			Source: "github.com/user/repo",
			Path:   "", // Path is initially empty for placeholder dependencies
		},
	}
	assert.Equal(t, expectedDependencies, generatedConfig.Dependencies, "Dependencies mismatch")

	// Optional: Check stdout content if needed (example)
	// stdoutContent := capturedOutput.String()
	// assert.Contains(t, stdoutContent, "Wrote to project.toml", "Expected confirmation message in output")
}

// Test case for empty description and no extra scripts/dependencies (uses defaults)
func TestInitCommand_DefaultsAndEmpty(t *testing.T) {
	// --- Test Setup ---
	tempDir, err := os.MkdirTemp("", "almandine_init_test_defaults")
	require.NoError(t, err, "Failed to create temporary directory")
	defer func() { _ = os.RemoveAll(tempDir) }()

	originalWd, err := os.Getwd()
	require.NoError(t, err, "Failed to get current working directory")
	err = os.Chdir(tempDir)
	require.NoError(t, err, "Failed to change to temporary directory")
	defer func() { _ = os.Chdir(originalWd) }()

	// Simulate pressing Enter for all prompts except name (use default)
	// name, version (default), license (default), description (empty), empty script, empty dep
	simulatedInputs := []string{
		"default-proj", // Package name
		"",             // Version (use default)
		"",             // License (use default)
		"",             // Description (empty)
		"",             // Empty script name (finish scripts)
		"",             // Empty dependency name (finish dependencies)
	}

	oldStdin := os.Stdin
	rStdin, _, err := simulateInput(simulatedInputs)
	require.NoError(t, err, "Failed to simulate stdin")
	os.Stdin = rStdin
	defer func() { os.Stdin = oldStdin; _ = rStdin.Close() }()

	oldStdout := os.Stdout
	rStdout, wStdout, _, err := captureOutput()
	require.NoError(t, err, "Failed to capture stdout")
	os.Stdout = wStdout
	defer func() { os.Stdout = oldStdout; _ = wStdout.Close(); _ = rStdout.Close() }()

	// --- Run Command ---
	app := &cli.App{
		Name: "almandine-test",
		Commands: []*cli.Command{
			GetInitCommand(),
		},
	}
	runErr := app.Run([]string{"almandine-test", "init"})

	// --- Assertions ---
	assert.NoError(t, runErr, "Init command returned an error")

	tomlPath := filepath.Join(tempDir, "project.toml")
	tomlBytes, err := os.ReadFile(tomlPath)
	require.NoError(t, err, "Failed to read project.toml")

	var generatedConfig project.Project
	err = toml.Unmarshal(tomlBytes, &generatedConfig)
	require.NoError(t, err, "Failed to unmarshal project.toml")

	// Verify Package Metadata (Defaults and empty description)
	assert.Equal(t, "default-proj", generatedConfig.Package.Name, "Package name mismatch")
	assert.Equal(t, "0.1.0", generatedConfig.Package.Version, "Version mismatch (default expected)")
	assert.Equal(t, "MIT", generatedConfig.Package.License, "License mismatch (default expected)")
	assert.Equal(t, "", generatedConfig.Package.Description, "Description should be empty") // Check omitempty worked

	// Verify Scripts (should only include the default 'run')
	expectedScripts := map[string]string{
		"run": "lua src/main.lua",
	}
	assert.Equal(t, expectedScripts, generatedConfig.Scripts, "Scripts mismatch (only default expected)")

	// Verify Dependencies (should be empty or nil)
	assert.Nil(t, generatedConfig.Dependencies, "Dependencies should be nil/omitted") // Or assert.Empty(...) if preferred
}



================================================
File: internal/cli/install/install.go
================================================
package install

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/urfave/cli/v2"

	"github.com/nightconcept/almandine-go/internal/core/config"
	"github.com/nightconcept/almandine-go/internal/core/downloader"
	"github.com/nightconcept/almandine-go/internal/core/hasher"
	"github.com/nightconcept/almandine-go/internal/core/lockfile"
	"github.com/nightconcept/almandine-go/internal/core/source"
)

var isCommitSHARegex = regexp.MustCompile(`^[0-9a-f]{7,40}$`) // Common Git SHA lengths

// NewInstallCommand creates a new cli.Command for the "install" command.
func NewInstallCommand() *cli.Command {
	return &cli.Command{
		Name:      "install",
		Usage:     "Installs or updates project dependencies based on project.toml",
		ArgsUsage: "[dependency_names...]",
		Flags: []cli.Flag{
			&cli.BoolFlag{
				Name:    "force",
				Aliases: []string{"f"},
				Usage:   "Force install/update even if versions appear to match",
			},
			&cli.BoolFlag{
				Name:  "verbose",
				Usage: "Enable verbose output",
			},
		},
		Action: func(c *cli.Context) error {
			verbose := c.Bool("verbose")
			force := c.Bool("force") // Keep force for later use

			if verbose {
				_, _ = fmt.Fprintln(os.Stdout, "Executing 'install' command...")
				if force {
					_, _ = fmt.Fprintln(os.Stdout, "Force install/update enabled.")
				}
			}

			dependencyNames := c.Args().Slice()
			if verbose {
				if len(dependencyNames) > 0 {
					_, _ = fmt.Fprintf(os.Stdout, "Targeted dependencies for install/update: %v\n", dependencyNames)
				} else {
					_, _ = fmt.Fprintln(os.Stdout, "Targeting all dependencies for install/update.")
				}
			}

			// Load project.toml
			projCfg, err := config.LoadProjectToml(".")
			if err != nil {
				if errors.Is(err, os.ErrNotExist) {
					return cli.Exit("Error: project.toml not found in the current directory. Please run 'almd init' first.", 1)
				}
				return cli.Exit(fmt.Sprintf("Error loading project.toml: %v", err), 1)
			}
			if verbose {
				_, _ = fmt.Fprintf(os.Stdout, "Successfully loaded project.toml (Package: %s)\n", projCfg.Package.Name)
			}

			// Load almd-lock.toml
			lf, err := lockfile.Load(".")
			if err != nil {
				return cli.Exit(fmt.Sprintf("Error loading almd-lock.toml: %v", err), 1)
			}
			if verbose {
				_, _ = fmt.Fprintln(os.Stdout, "Successfully loaded or initialized almd-lock.toml.")
			}
			if lf.Package == nil {
				lf.Package = make(map[string]lockfile.PackageEntry)
			}
			if lf.ApiVersion == "" {
				lf.ApiVersion = lockfile.APIVersion
			}

			// --- Task 6.3: Dependency Iteration and Configuration Retrieval ---
			type dependencyToProcess struct {
				Name   string
				Source string
				Path   string
			}
			var dependenciesToProcessList []dependencyToProcess

			if len(dependencyNames) == 0 { // Install/update all dependencies defined in project.toml
				if len(projCfg.Dependencies) == 0 {
					_, _ = fmt.Fprintln(os.Stdout, "No dependencies found in project.toml to install/update.")
					return nil
				}
				if verbose {
					_, _ = fmt.Fprintf(os.Stdout, "Processing all %d dependencies from project.toml...\n", len(projCfg.Dependencies))
				}
				for name, depDetails := range projCfg.Dependencies {
					dependenciesToProcessList = append(dependenciesToProcessList, dependencyToProcess{
						Name:   name,
						Source: depDetails.Source,
						Path:   depDetails.Path,
					})
					if verbose {
						_, _ = fmt.Fprintf(os.Stdout, "  Targeting: %s (Source: %s, Path: %s)\n", name, depDetails.Source, depDetails.Path)
					}
				}
			} else { // Install/update specific dependencies
				if verbose {
					_, _ = fmt.Fprintf(os.Stdout, "Processing %d specified dependencies...\n", len(dependencyNames))
				}
				for _, name := range dependencyNames {
					depDetails, ok := projCfg.Dependencies[name]
					if !ok {
						_, _ = fmt.Fprintf(os.Stderr, "Warning: Dependency '%s' specified for install/update not found in project.toml. Skipping.\n", name)
						continue
					}
					dependenciesToProcessList = append(dependenciesToProcessList, dependencyToProcess{
						Name:   name,
						Source: depDetails.Source,
						Path:   depDetails.Path,
					})
					if verbose {
						_, _ = fmt.Fprintf(os.Stdout, "  Targeting: %s (Source: %s, Path: %s)\n", name, depDetails.Source, depDetails.Path)
					}
				}
				if len(dependenciesToProcessList) == 0 {
					_, _ = fmt.Fprintln(os.Stdout, "No specified dependencies were found in project.toml to install/update.")
					return nil
				}
			}

			if verbose {
				_, _ = fmt.Fprintf(os.Stdout, "Total dependencies to process: %d\n", len(dependenciesToProcessList))
			}

			// --- Task 6.4: Target Version Resolution and Lockfile State Retrieval ---
			type dependencyInstallState struct {
				Name              string
				ProjectTomlSource string // Original source string from project.toml
				ProjectTomlPath   string // Path from project.toml
				TargetRawURL      string // Resolved raw URL for download
				TargetCommitHash  string // Resolved definitive commit hash (or tag/branch if not resolvable to commit)
				LockedRawURL      string // Raw URL from almd-lock.toml
				LockedCommitHash  string // Hash from almd-lock.toml (could be commit:<sha> or sha256:<hash>)
				Provider          string
				Owner             string
				Repo              string
				PathInRepo        string
				NeedsAction       bool   // Flag to indicate if this dependency needs to be installed/updated
				ActionReason      string // Reason why an action is needed
			}
			var installStates []dependencyInstallState

			if verbose && len(dependenciesToProcessList) > 0 {
				_, _ = fmt.Fprintln(os.Stdout, "\nResolving target versions and current lock states...")
			}

			for _, depToProcess := range dependenciesToProcessList {
				if verbose {
					_, _ = fmt.Fprintf(os.Stdout, "Processing dependency: %s (Source: %s)\n", depToProcess.Name, depToProcess.Source)
				}

				parsedSourceInfo, err := source.ParseSourceURL(depToProcess.Source)
				if err != nil {
					_, _ = fmt.Fprintf(os.Stderr, "Warning: Could not parse source URL for dependency '%s' (%s): %v. Skipping.\n", depToProcess.Name, depToProcess.Source, err)
					continue
				}

				var resolvedCommitHash = parsedSourceInfo.Ref // Default to the ref from parsing
				var finalTargetRawURL = parsedSourceInfo.RawURL

				if parsedSourceInfo.Provider == "github" && !isCommitSHARegex.MatchString(parsedSourceInfo.Ref) {
					if verbose {
						_, _ = fmt.Fprintf(os.Stdout, "  Ref '%s' for '%s' is not a full commit SHA. Attempting to resolve latest commit for path '%s'...\n", parsedSourceInfo.Ref, depToProcess.Name, parsedSourceInfo.PathInRepo)
					}
					latestSHA, err := source.GetLatestCommitSHAForFile(parsedSourceInfo.Owner, parsedSourceInfo.Repo, parsedSourceInfo.PathInRepo, parsedSourceInfo.Ref)
					if err != nil {
						_, _ = fmt.Fprintf(os.Stderr, "  Warning: Could not resolve ref '%s' to a specific commit for '%s': %v. Proceeding with ref as is.\n", parsedSourceInfo.Ref, depToProcess.Name, err)
					} else {
						if verbose {
							_, _ = fmt.Fprintf(os.Stdout, "  Resolved ref '%s' to commit SHA: %s for '%s'\n", parsedSourceInfo.Ref, latestSHA, depToProcess.Name)
						}
						resolvedCommitHash = latestSHA
						finalTargetRawURL = strings.Replace(parsedSourceInfo.RawURL, "/"+parsedSourceInfo.Ref+"/", "/"+latestSHA+"/", 1)
					}
				} else if verbose && parsedSourceInfo.Provider == "github" {
					_, _ = fmt.Fprintf(os.Stdout, "  Ref '%s' for '%s' appears to be a commit SHA. Using it directly.\n", parsedSourceInfo.Ref, depToProcess.Name)
				}

				currentState := dependencyInstallState{
					Name:              depToProcess.Name,
					ProjectTomlSource: depToProcess.Source,
					ProjectTomlPath:   depToProcess.Path,
					TargetRawURL:      finalTargetRawURL,
					TargetCommitHash:  resolvedCommitHash,
					Provider:          parsedSourceInfo.Provider,
					Owner:             parsedSourceInfo.Owner,
					Repo:              parsedSourceInfo.Repo,
					PathInRepo:        parsedSourceInfo.PathInRepo,
				}

				if lockDetails, ok := lf.Package[depToProcess.Name]; ok {
					currentState.LockedRawURL = lockDetails.Source
					currentState.LockedCommitHash = lockDetails.Hash
					if verbose {
						_, _ = fmt.Fprintf(os.Stdout, "  Found in lockfile: Name: %s, Locked Source: %s, Locked Hash: %s\n", depToProcess.Name, lockDetails.Source, lockDetails.Hash)
					}
				} else {
					if verbose {
						_, _ = fmt.Fprintf(os.Stdout, "  Dependency '%s' not found in lockfile.\n", depToProcess.Name)
					}
				}
				installStates = append(installStates, currentState)
			}

			if verbose && len(installStates) > 0 {
				_, _ = fmt.Fprintln(os.Stdout, "\nFinished resolving versions. States to compare:")
				for _, s := range installStates {
					_, _ = fmt.Fprintf(os.Stdout, "  - Name: %s, TargetCommit: %s, TargetURL: %s, LockedHash: %s, LockedURL: %s\n", s.Name, s.TargetCommitHash, s.TargetRawURL, s.LockedCommitHash, s.LockedRawURL)
				}
			}

			// --- Task 6.5: Comparison Logic and Update Decision ---
			var dependenciesThatNeedAction []dependencyInstallState

			if verbose && len(installStates) > 0 {
				_, _ = fmt.Fprintln(os.Stdout, "\nDetermining which dependencies need install/update...")
			}

			for i, state := range installStates {
				reason := ""
				needsAction := false

				// 1. --force flag
				if force {
					needsAction = true
					reason = "Install/Update forced by user (--force)."
					if verbose {
						_, _ = fmt.Fprintf(os.Stdout, "  - %s: Needs install/update (forced).\n", state.Name)
					}
				}

				// 2. Dependency in project.toml but missing from almd-lock.toml
				if !needsAction && state.LockedCommitHash == "" {
					needsAction = true
					reason = "Dependency present in project.toml but not in almd-lock.toml."
					if verbose {
						_, _ = fmt.Fprintf(os.Stdout, "  - %s: Needs install/update (not in lockfile).\n", state.Name)
					}
				}

				// 3. Local file at path is missing
				if !needsAction {
					if _, err := os.Stat(state.ProjectTomlPath); errors.Is(err, os.ErrNotExist) {
						needsAction = true
						reason = fmt.Sprintf("Local file missing at path: %s.", state.ProjectTomlPath)
						if verbose {
							_, _ = fmt.Fprintf(os.Stdout, "  - %s: Needs install/update (file missing at %s).\n", state.Name, state.ProjectTomlPath)
						}
					} else if err != nil {
						_, _ = fmt.Fprintf(os.Stderr, "Warning: Could not stat file for dependency '%s' at '%s': %v. Assuming install/update check is needed.\n", state.Name, state.ProjectTomlPath, err)
						needsAction = true
						reason = fmt.Sprintf("Error checking local file status at %s: %v.", state.ProjectTomlPath, err)
					}
				}

				// 4. Resolved target commit hash differs from locked commit hash
				if !needsAction && state.TargetCommitHash != "" && state.LockedCommitHash != "" {
					var lockedSHA string
					if strings.HasPrefix(state.LockedCommitHash, "commit:") {
						lockedSHA = strings.TrimPrefix(state.LockedCommitHash, "commit:")
					}

					if lockedSHA != "" && state.TargetCommitHash != lockedSHA {
						needsAction = true
						reason = fmt.Sprintf("Target commit hash (%s) differs from locked commit hash (%s).", state.TargetCommitHash, lockedSHA)
						if verbose {
							_, _ = fmt.Fprintf(os.Stdout, "  - %s: Needs install/update (target commit %s != locked commit %s).\n", state.Name, state.TargetCommitHash, lockedSHA)
						}
					} else if lockedSHA == "" && strings.HasPrefix(state.LockedCommitHash, "sha256:") && isCommitSHARegex.MatchString(state.TargetCommitHash) {
						needsAction = true
						reason = fmt.Sprintf("Target is now a specific commit (%s), but lockfile has a content hash (%s).", state.TargetCommitHash, state.LockedCommitHash)
						if verbose {
							_, _ = fmt.Fprintf(os.Stdout, "  - %s: Needs install/update (target is specific commit %s, lockfile has content hash %s).\n", state.Name, state.TargetCommitHash, state.LockedCommitHash)
						}
					}
				}

				if needsAction {
					installStates[i].NeedsAction = true
					installStates[i].ActionReason = reason
					dependenciesThatNeedAction = append(dependenciesThatNeedAction, installStates[i])
				} else if verbose {
					_, _ = fmt.Fprintf(os.Stdout, "  - %s: Already up-to-date.\n", state.Name)
				}
			}

			if len(dependenciesThatNeedAction) == 0 {
				_, _ = fmt.Fprintln(os.Stdout, "All targeted dependencies are already up-to-date.")
				return nil
			}

			if verbose {
				_, _ = fmt.Fprintf(os.Stdout, "\nDependencies to be installed/updated (%d):\n", len(dependenciesThatNeedAction))
				for _, dep := range dependenciesThatNeedAction {
					_, _ = fmt.Fprintf(os.Stdout, "  - %s (Reason: %s)\n", dep.Name, dep.ActionReason)
				}
			}

			// --- Task 6.6: Perform Install/Update (If Required) ---
			if verbose && len(dependenciesThatNeedAction) > 0 {
				_, _ = fmt.Fprintln(os.Stdout, "\nPerforming install/update for identified dependencies...")
			}

			var successfulActions int
			for _, dep := range dependenciesThatNeedAction {
				if verbose {
					_, _ = fmt.Fprintf(os.Stdout, "  Installing/Updating '%s' from %s\n", dep.Name, dep.TargetRawURL)
				}

				fileContent, err := downloader.DownloadFile(dep.TargetRawURL)
				if err != nil {
					_, _ = fmt.Fprintf(os.Stderr, "Error: Failed to download dependency '%s' from '%s': %v\n", dep.Name, dep.TargetRawURL, err)
					continue
				}
				if verbose {
					_, _ = fmt.Fprintf(os.Stdout, "    Successfully downloaded %s (%d bytes)\n", dep.Name, len(fileContent))
				}

				var integrityHash string
				if dep.Provider == "github" && isCommitSHARegex.MatchString(dep.TargetCommitHash) {
					integrityHash = "commit:" + dep.TargetCommitHash
					if verbose {
						_, _ = fmt.Fprintf(os.Stdout, "    Using commit hash for integrity: %s\n", integrityHash)
					}
				} else {
					contentHash, err := hasher.CalculateSHA256(fileContent)
					if err != nil {
						_, _ = fmt.Fprintf(os.Stderr, "Error: Failed to calculate SHA256 hash for dependency '%s': %v\n", dep.Name, err)
						continue
					}
					integrityHash = contentHash
					if verbose {
						_, _ = fmt.Fprintf(os.Stdout, "    Calculated content hash for integrity: %s\n", integrityHash)
					}
				}

				targetDir := filepath.Dir(dep.ProjectTomlPath)
				if err := os.MkdirAll(targetDir, os.ModePerm); err != nil {
					_, _ = fmt.Fprintf(os.Stderr, "Error: Failed to create directory '%s' for dependency '%s': %v\n", targetDir, dep.Name, err)
					continue
				}
				if err := os.WriteFile(dep.ProjectTomlPath, fileContent, 0644); err != nil {
					_, _ = fmt.Fprintf(os.Stderr, "Error: Failed to write file '%s' for dependency '%s': %v\n", dep.ProjectTomlPath, dep.Name, err)
					continue
				}
				if verbose {
					_, _ = fmt.Fprintf(os.Stdout, "    Successfully saved %s to %s\n", dep.Name, dep.ProjectTomlPath)
				}

				lf.Package[dep.Name] = lockfile.PackageEntry{
					Source: dep.TargetRawURL,
					Path:   dep.ProjectTomlPath,
					Hash:   integrityHash,
				}
				if verbose {
					_, _ = fmt.Fprintf(os.Stdout, "    Updated lockfile entry for %s: Path=%s, Hash=%s, SourceURL=%s\n", dep.Name, dep.ProjectTomlPath, integrityHash, dep.TargetRawURL)
				}
				successfulActions++
			}

			if successfulActions > 0 {
				lf.ApiVersion = lockfile.APIVersion
				if err := lockfile.Save(".", lf); err != nil {
					return cli.Exit(fmt.Sprintf("Error: Failed to save updated almd-lock.toml: %v", err), 1)
				}
				if verbose {
					_, _ = fmt.Fprintf(os.Stdout, "\nSuccessfully saved almd-lock.toml with %d action(s).\n", successfulActions)
				}
				_, _ = fmt.Fprintf(os.Stdout, "Successfully installed/updated %d dependenc(ies).\n", successfulActions)
			} else {
				if len(dependenciesThatNeedAction) > 0 {
					_, _ = fmt.Fprintln(os.Stderr, "No dependencies were successfully installed/updated due to errors.")
					return cli.Exit("Install/Update process completed with errors for all targeted dependencies.", 1)
				}
			}
			return nil
		},
	}
}



================================================
File: internal/cli/install/install_test.go
================================================
// Title: Almandine CLI Install Command Tests
// Purpose: Contains test cases for the 'install' command of the Almandine CLI.
package install_test

import (
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"testing"

	"github.com/BurntSushi/toml"
	installcmd "github.com/nightconcept/almandine-go/internal/cli/install" // Import the package being tested
	"github.com/nightconcept/almandine-go/internal/core/config"
	"github.com/nightconcept/almandine-go/internal/core/lockfile"
	"github.com/nightconcept/almandine-go/internal/core/project"
	"github.com/nightconcept/almandine-go/internal/core/source"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/urfave/cli/v2"
)

func init() {
	// Enable host validation bypass for testing with mock server
	source.SetTestModeBypassHostValidation(true)
}

// startMockHTTPServer starts an httptest.Server that serves specific responses
// for a map of expected paths. Other paths will result in a 404.
// Adapted from add_test.go
func startMockHTTPServer(t *testing.T, pathResponses map[string]struct {
	Body string
	Code int
}) *httptest.Server {
	t.Helper()
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		requestPathWithQuery := r.URL.Path
		if r.URL.RawQuery != "" {
			requestPathWithQuery += "?" + r.URL.RawQuery
		}

		for path, response := range pathResponses {
			if r.Method == http.MethodGet && (r.URL.Path == path || requestPathWithQuery == path) {
				w.WriteHeader(response.Code)
				_, err := w.Write([]byte(response.Body))
				assert.NoError(t, err, "Mock server failed to write response body for path: %s", path)
				return
			}
		}
		t.Logf("Mock server: unexpected request: Method %s, Path %s, Query %s", r.Method, r.URL.Path, r.URL.RawQuery)
		http.NotFound(w, r)
	}))
	t.Cleanup(server.Close)
	return server
}

// setupInstallTestEnvironment creates a temporary directory for testing and initializes
// project.toml, almd-lock.toml, and optionally mock dependency files.
// Returns the path to the temporary directory.
func setupInstallTestEnvironment(t *testing.T, initialProjectTomlContent string, initialLockfileContent string, mockDepFiles map[string]string) (tempDir string) {
	t.Helper()
	tempDir = t.TempDir()

	if initialProjectTomlContent != "" {
		projectTomlPath := filepath.Join(tempDir, config.ProjectTomlName)
		err := os.WriteFile(projectTomlPath, []byte(initialProjectTomlContent), 0644)
		require.NoError(t, err, "Failed to write initial project.toml")
	}

	if initialLockfileContent != "" {
		lockfilePath := filepath.Join(tempDir, lockfile.LockfileName)
		err := os.WriteFile(lockfilePath, []byte(initialLockfileContent), 0644)
		require.NoError(t, err, "Failed to write initial almd-lock.toml")
	}

	for relPath, content := range mockDepFiles {
		absPath := filepath.Join(tempDir, relPath)
		err := os.MkdirAll(filepath.Dir(absPath), 0755)
		require.NoError(t, err, "Failed to create directory for mock dep file: %s", filepath.Dir(absPath))
		err = os.WriteFile(absPath, []byte(content), 0644)
		require.NoError(t, err, "Failed to write mock dependency file: %s", absPath)
	}

	return tempDir
}

// runInstallCommand executes the 'install' command within a specific working directory.
func runInstallCommand(t *testing.T, workDir string, installCmdArgs ...string) error {
	t.Helper()

	originalWd, err := os.Getwd()
	require.NoError(t, err, "Failed to get current working directory")
	err = os.Chdir(workDir)
	require.NoError(t, err, "Failed to change to working directory: %s", workDir)
	defer func() {
		require.NoError(t, os.Chdir(originalWd), "Failed to restore original working directory")
	}()

	app := &cli.App{
		Name: "almd-test-install",
		Commands: []*cli.Command{
			installcmd.NewInstallCommand(),
		},
		Writer:    os.Stderr,
		ErrWriter: os.Stderr,
		ExitErrHandler: func(context *cli.Context, err error) {
			// Do nothing, let test assertions handle errors
		},
	}

	cliArgs := []string{"almd-test-install", "install"}
	cliArgs = append(cliArgs, installCmdArgs...)

	return app.Run(cliArgs)
}

// Helper to read project.toml, adapted from add_test.go
func readProjectToml(t *testing.T, tomlPath string) project.Project {
	t.Helper()
	bytes, err := os.ReadFile(tomlPath)
	require.NoError(t, err, "Failed to read project.toml: %s", tomlPath)

	var projCfg project.Project
	err = toml.Unmarshal(bytes, &projCfg)
	require.NoError(t, err, "Failed to unmarshal project.toml: %s", tomlPath)
	return projCfg
}

// Helper to read almd-lock.toml, adapted from add_test.go
func readAlmdLockToml(t *testing.T, lockPath string) lockfile.Lockfile {
	t.Helper()
	bytes, err := os.ReadFile(lockPath)
	require.NoError(t, err, "Failed to read almd-lock.toml: %s", lockPath)

	var lockCfg lockfile.Lockfile
	err = toml.Unmarshal(bytes, &lockCfg)
	require.NoError(t, err, "Failed to unmarshal almd-lock.toml: %s", lockPath)
	return lockCfg
}

// Task 7.2.1: Test `almd install` - All dependencies, one needs install (commit hash change)
func TestInstallCommand_OneDepNeedsUpdate_CommitHashChange(t *testing.T) {
	depAName := "depA"
	depAPath := "libs/depA.lua"
	depAOriginalContent := "local depA_v1 = true"
	depANewContent := "local depA_v2 = true; print('updated')"

	initialProjectToml := fmt.Sprintf(`
[package]
name = "test-install-project"
version = "0.1.0"

[dependencies.%s]
source = "github:testowner/testrepo/%s@main"
path = "%s"
`, depAName, depAPath, depAPath) // Assuming file name in repo is same as path for simplicity

	initialLockfile := fmt.Sprintf(`
api_version = "1"

[package.%s]
source = "https://raw.githubusercontent.com/testowner/testrepo/commit1_sha_abcdef1234567890/%s"
path = "%s"
hash = "commit:commit1_sha_abcdef1234567890"
`, depAName, depAPath, depAPath)

	mockFiles := map[string]string{
		depAPath: depAOriginalContent,
	}

	tempDir := setupInstallTestEnvironment(t, initialProjectToml, initialLockfile, mockFiles)

	// Mock server setup
	// 1. GitHub API call to resolve 'main' for depA to a valid hex commit SHA
	// 2. Raw content download for depA using that commit SHA
	commit2SHA := "fedcba0987654321abcdef1234567890" // Valid hex SHA
	// Path for GetLatestCommitSHAForFile: /repos/<owner>/<repo>/commits?path=<file_path_in_repo>&sha=<ref>&per_page=1
	// The <file_path_in_repo> is extracted from the canonical source string.
	// Canonical source: "github:testowner/testrepo/libs/depA.lua@main" -> file_path_in_repo: "libs/depA.lua"
	githubAPIPathForDepA := fmt.Sprintf("/repos/testowner/testrepo/commits?path=%s&sha=main&per_page=1", depAPath)
	githubAPIResponseForDepA := fmt.Sprintf(`[{"sha": "%s"}]`, commit2SHA)

	// Raw download URL path for depA with new commit
	// source.go constructs this as: /<owner>/<repo>/<commit_sha>/<file_path_in_repo>
	// when testModeBypassHostValidation is true.
	rawDownloadPathDepA := fmt.Sprintf("/testowner/testrepo/%s/%s", commit2SHA, depAPath)

	pathResps := map[string]struct {
		Body string
		Code int
	}{
		githubAPIPathForDepA: {Body: githubAPIResponseForDepA, Code: http.StatusOK},
		rawDownloadPathDepA:  {Body: depANewContent, Code: http.StatusOK},
	}
	mockServer := startMockHTTPServer(t, pathResps)

	// Override GitHub API base URL to point to mock server
	originalGHAPIBaseURL := source.GithubAPIBaseURL
	source.GithubAPIBaseURL = mockServer.URL
	defer func() { source.GithubAPIBaseURL = originalGHAPIBaseURL }()

	// Override Raw GitHub Content base URL (used by downloader if source.ParseSourceURL returns a raw URL directly)
	// For test mode, source.ParseSourceURL constructs a full mock server URL if it's a GitHub source.
	// So, this override might not be strictly necessary if GithubAPIBaseURL is correctly used by ParseSourceURL
	// to build the *raw* download URL for the mock server.
	// Let's assume source.ParseSourceURL will use the mockServer.URL correctly for raw downloads in test mode.

	// --- Run Command ---
	err := runInstallCommand(t, tempDir) // No specific args, should install all from project.toml
	require.NoError(t, err, "almd install command failed")

	// --- Assertions ---
	// 1. Verify depA file content is updated
	depAFilePath := filepath.Join(tempDir, depAPath)
	updatedContentBytes, readErr := os.ReadFile(depAFilePath)
	require.NoError(t, readErr, "Failed to read updated depA file: %s", depAFilePath)
	assert.Equal(t, depANewContent, string(updatedContentBytes), "depA file content mismatch after install")

	// 2. Verify almd-lock.toml is updated for depA
	lockFilePath := filepath.Join(tempDir, lockfile.LockfileName)
	updatedLockCfg := readAlmdLockToml(t, lockFilePath)

	require.NotNil(t, updatedLockCfg.Package, "Packages map in almd-lock.toml is nil after install")
	depALockEntry, ok := updatedLockCfg.Package[depAName]
	require.True(t, ok, "depA entry not found in almd-lock.toml after install")

	// Expected raw source URL in lockfile should point to the new commit on the mock server
	expectedLockSourceURL := mockServer.URL + rawDownloadPathDepA
	assert.Equal(t, expectedLockSourceURL, depALockEntry.Source, "depA lockfile source URL mismatch")
	assert.Equal(t, depAPath, depALockEntry.Path, "depA lockfile path mismatch")
	assert.Equal(t, "commit:"+commit2SHA, depALockEntry.Hash, "depA lockfile hash mismatch")

	// 3. Verify project.toml remains unchanged (install doesn't modify project.toml sources)
	projTomlPath := filepath.Join(tempDir, config.ProjectTomlName)
	currentProjCfg := readProjectToml(t, projTomlPath)
	depAProjEntry, ok := currentProjCfg.Dependencies[depAName]
	require.True(t, ok, "depA entry not found in project.toml")
	assert.Equal(t, fmt.Sprintf("github:testowner/testrepo/%s@main", depAPath), depAProjEntry.Source, "project.toml source for depA should not change")
}

// Task 7.2.2: Test `almd install <dep_name>` - Specific dependency install
func TestInstallCommand_SpecificDepInstall_OneNeedsUpdate(t *testing.T) {
	depAName := "depA"
	depAPath := "libs/depA.lua"
	depAOriginalContent := "local depA_v1 = true"
	depANewContent := "local depA_v2 = true; print('updated A')"
	depACommit1HexSHA := "abcdef1234567890abcdef1234567890" // Valid hex
	depACommit2HexSHA := "fedcba0987654321fedcba0987654321" // Valid hex

	depBName := "depB"
	depBPath := "modules/depB.lua"
	depBOriginalContent := "local depB_v1 = true"
	depBNewContent := "local depB_v2 = true; print('updated B')" // Should not be used
	depBCommit1HexSHA := "1234567890abcdef1234567890abcdef"      // Valid hex
	depBCommit2HexSHA := "0987654321fedcba0987654321fedcba"      // Valid hex

	initialProjectToml := fmt.Sprintf(`
[package]
name = "test-specific-install"
version = "0.1.0"

[dependencies.%s]
source = "github:testowner/testrepo/%s@main"
path = "%s"

[dependencies.%s]
source = "github:anotherowner/anotherrepo/%s@main"
path = "%s"
`, depAName, depAPath, depAPath, depBName, depBPath, depBPath)

	initialLockfile := fmt.Sprintf(`
api_version = "1"

[package.%s]
source = "https://raw.githubusercontent.com/testowner/testrepo/%s/%s"
path = "%s"
hash = "commit:%s"

[package.%s]
source = "https://raw.githubusercontent.com/anotherowner/anotherrepo/%s/%s"
path = "%s"
hash = "commit:%s"
`, depAName, depACommit1HexSHA, depAPath, depAPath, depACommit1HexSHA,
		depBName, depBCommit1HexSHA, depBPath, depBPath, depBCommit1HexSHA)

	mockFiles := map[string]string{
		depAPath: depAOriginalContent,
		depBPath: depBOriginalContent,
	}

	tempDir := setupInstallTestEnvironment(t, initialProjectToml, initialLockfile, mockFiles)

	// Mock server setup
	githubAPIPathForDepA := fmt.Sprintf("/repos/testowner/testrepo/commits?path=%s&sha=main&per_page=1", depAPath)
	githubAPIResponseForDepA := fmt.Sprintf(`[{"sha": "%s"}]`, depACommit2HexSHA)
	rawDownloadPathDepA := fmt.Sprintf("/testowner/testrepo/%s/%s", depACommit2HexSHA, depAPath)

	githubAPIPathForDepB := fmt.Sprintf("/repos/anotherowner/anotherrepo/commits?path=%s&sha=main&per_page=1", depBPath)
	githubAPIResponseForDepB := fmt.Sprintf(`[{"sha": "%s"}]`, depBCommit2HexSHA)
	rawDownloadPathDepB := fmt.Sprintf("/anotherowner/anotherrepo/%s/%s", depBCommit2HexSHA, depBPath)

	pathResps := map[string]struct {
		Body string
		Code int
	}{
		githubAPIPathForDepA: {Body: githubAPIResponseForDepA, Code: http.StatusOK},
		rawDownloadPathDepA:  {Body: depANewContent, Code: http.StatusOK},
		githubAPIPathForDepB: {Body: githubAPIResponseForDepB, Code: http.StatusOK}, // depB might be checked by source resolver even if not installed
		rawDownloadPathDepB:  {Body: depBNewContent, Code: http.StatusOK},           // Should not be called
	}
	mockServer := startMockHTTPServer(t, pathResps)

	originalGHAPIBaseURL := source.GithubAPIBaseURL
	source.GithubAPIBaseURL = mockServer.URL
	defer func() { source.GithubAPIBaseURL = originalGHAPIBaseURL }()

	// --- Run Command for depA only ---
	err := runInstallCommand(t, tempDir, depAName)
	require.NoError(t, err, "almd install %s command failed", depAName)

	// --- Assertions for depA ---
	depAFilePath := filepath.Join(tempDir, depAPath)
	updatedContentBytesA, readErrA := os.ReadFile(depAFilePath)
	require.NoError(t, readErrA, "Failed to read updated depA file: %s", depAFilePath)
	assert.Equal(t, depANewContent, string(updatedContentBytesA), "depA file content mismatch after specific install")

	lockFilePath := filepath.Join(tempDir, lockfile.LockfileName)
	updatedLockCfg := readAlmdLockToml(t, lockFilePath)
	require.NotNil(t, updatedLockCfg.Package, "Packages map in almd-lock.toml is nil")

	depALockEntry, okA := updatedLockCfg.Package[depAName]
	require.True(t, okA, "depA entry not found in almd-lock.toml after specific install")
	expectedLockSourceURLA := mockServer.URL + rawDownloadPathDepA
	assert.Equal(t, expectedLockSourceURLA, depALockEntry.Source, "depA lockfile source URL mismatch")
	assert.Equal(t, "commit:"+depACommit2HexSHA, depALockEntry.Hash, "depA lockfile hash mismatch")

	// --- Assertions for depB (should be unchanged) ---
	depBFilePath := filepath.Join(tempDir, depBPath)
	contentBytesB, readErrB := os.ReadFile(depBFilePath)
	require.NoError(t, readErrB, "Failed to read depB file: %s", depBFilePath)
	assert.Equal(t, depBOriginalContent, string(contentBytesB), "depB file content should not have changed")

	depBLockEntry, okB := updatedLockCfg.Package[depBName]
	require.True(t, okB, "depB entry not found in almd-lock.toml")
	expectedLockSourceURLBOriginal := fmt.Sprintf("https://raw.githubusercontent.com/anotherowner/anotherrepo/%s/%s", depBCommit1HexSHA, depBPath) // Original URL
	assert.Equal(t, expectedLockSourceURLBOriginal, depBLockEntry.Source, "depB lockfile source URL should be unchanged")
	assert.Equal(t, "commit:"+depBCommit1HexSHA, depBLockEntry.Hash, "depB lockfile hash should be unchanged")

	// Verify project.toml remains unchanged
	projTomlPath := filepath.Join(tempDir, config.ProjectTomlName)
	currentProjCfg := readProjectToml(t, projTomlPath)
	depAProjEntry := currentProjCfg.Dependencies[depAName]
	assert.Equal(t, fmt.Sprintf("github:testowner/testrepo/%s@main", depAPath), depAProjEntry.Source)
	depBProjEntry := currentProjCfg.Dependencies[depBName]
	assert.Equal(t, fmt.Sprintf("github:anotherowner/anotherrepo/%s@main", depBPath), depBProjEntry.Source)
}

// Task 7.2.3: Test `almd install` - All dependencies up-to-date
func TestInstallCommand_AllDepsUpToDate(t *testing.T) {
	depAName := "depA"
	depAPath := "libs/depA.lua"
	depAContent := "local depA_v_current = true"
	depACommitCurrentSHA := "commitA_sha_current12345"

	initialProjectToml := fmt.Sprintf(`
[package]
name = "test-uptodate-project"
version = "0.1.0"

[dependencies.%s]
source = "github:testowner/testrepo/%s@main"
path = "%s"
`, depAName, depAPath, depAPath)

	// Lockfile points to the current commit, and local file matches this version
	initialLockfile := fmt.Sprintf(`
api_version = "1"

[package.%s]
source = "https://raw.githubusercontent.com/testowner/testrepo/%s/%s"
path = "%s"
hash = "commit:%s"
`, depAName, depACommitCurrentSHA, depAPath, depAPath, depACommitCurrentSHA)

	mockFiles := map[string]string{
		depAPath: depAContent, // Local file exists and is "current"
	}

	tempDir := setupInstallTestEnvironment(t, initialProjectToml, initialLockfile, mockFiles)

	// Mock server setup
	// GitHub API call to resolve 'main' for depA should return the *same* current SHA
	githubAPIPathForDepA := fmt.Sprintf("/repos/testowner/testrepo/commits?path=%s&sha=main&per_page=1", depAPath)
	githubAPIResponseForDepA := fmt.Sprintf(`[{"sha": "%s"}]`, depACommitCurrentSHA)

	// Raw download path - should ideally not be called if dep is up-to-date.
	// If it were called, it would serve the same content.
	rawDownloadPathDepA := fmt.Sprintf("/testowner/testrepo/%s/%s", depACommitCurrentSHA, depAPath)

	pathResps := map[string]struct {
		Body string
		Code int
	}{
		githubAPIPathForDepA: {Body: githubAPIResponseForDepA, Code: http.StatusOK},
		rawDownloadPathDepA:  {Body: depAContent, Code: http.StatusOK}, // Should not be fetched
	}
	mockServer := startMockHTTPServer(t, pathResps)

	originalGHAPIBaseURL := source.GithubAPIBaseURL
	source.GithubAPIBaseURL = mockServer.URL
	defer func() { source.GithubAPIBaseURL = originalGHAPIBaseURL }()

	// --- Run Command ---
	err := runInstallCommand(t, tempDir) // Install all
	require.NoError(t, err, "almd install command failed")

	// --- Assertions ---
	// 1. Verify depA file content is UNCHANGED
	depAFilePath := filepath.Join(tempDir, depAPath)
	currentContentBytes, readErr := os.ReadFile(depAFilePath)
	require.NoError(t, readErr, "Failed to read depA file: %s", depAFilePath)
	assert.Equal(t, depAContent, string(currentContentBytes), "depA file content should be unchanged")

	// 2. Verify almd-lock.toml is UNCHANGED
	lockFilePath := filepath.Join(tempDir, lockfile.LockfileName)
	currentLockCfg := readAlmdLockToml(t, lockFilePath) // Read current
	originalLockCfg := lockfile.Lockfile{}              // For comparison
	errUnmarshal := toml.Unmarshal([]byte(initialLockfile), &originalLockCfg)
	require.NoError(t, errUnmarshal, "Failed to unmarshal original lockfile content for comparison")

	assert.Equal(t, originalLockCfg, currentLockCfg, "almd-lock.toml should be unchanged")

	// 3. Verify project.toml remains unchanged
	projTomlPath := filepath.Join(tempDir, config.ProjectTomlName)
	currentProjCfg := readProjectToml(t, projTomlPath)
	originalProjCfg := project.Project{}
	errUnmarshalProj := toml.Unmarshal([]byte(initialProjectToml), &originalProjCfg)
	require.NoError(t, errUnmarshalProj, "Failed to unmarshal original project.toml content for comparison")
	assert.Equal(t, originalProjCfg, currentProjCfg, "project.toml should be unchanged")
}

// Task 7.2.4: Test `almd install` - Dependency in `project.toml` but missing from `almd-lock.toml`
func TestInstallCommand_DepInProjectToml_MissingFromLockfile(t *testing.T) {
	depNewName := "depNew"
	depNewPath := "libs/depNew.lua"
	depNewContent := "local depNewContent = true"
	depNewCommitSHA := "abcdef1234567890abcdef1234567890" // Valid hex

	initialProjectToml := fmt.Sprintf(`
[package]
name = "test-missing-lockfile-entry"
version = "0.1.0"

[dependencies.%s]
source = "github:testowner/newrepo/%s@main"
path = "%s"
`, depNewName, depNewPath, depNewPath)

	// Lockfile is initially empty or does not contain depNew
	initialLockfile := `
api_version = "1"
[package]
# depNew is missing here
`
	tempDir := setupInstallTestEnvironment(t, initialProjectToml, initialLockfile, nil) // No initial mock files for depNew

	// Mock server setup
	githubAPIPathForDepNew := fmt.Sprintf("/repos/testowner/newrepo/commits?path=%s&sha=main&per_page=1", depNewPath)
	githubAPIResponseForDepNew := fmt.Sprintf(`[{"sha": "%s"}]`, depNewCommitSHA)
	rawDownloadPathDepNew := fmt.Sprintf("/testowner/newrepo/%s/%s", depNewCommitSHA, depNewPath)

	pathResps := map[string]struct {
		Body string
		Code int
	}{
		githubAPIPathForDepNew: {Body: githubAPIResponseForDepNew, Code: http.StatusOK},
		rawDownloadPathDepNew:  {Body: depNewContent, Code: http.StatusOK},
	}
	mockServer := startMockHTTPServer(t, pathResps)

	originalGHAPIBaseURL := source.GithubAPIBaseURL
	source.GithubAPIBaseURL = mockServer.URL
	defer func() { source.GithubAPIBaseURL = originalGHAPIBaseURL }()

	// --- Run Command ---
	err := runInstallCommand(t, tempDir) // Install all
	require.NoError(t, err, "almd install command failed")

	// --- Assertions ---
	// 1. Verify depNew file is created with correct content
	depNewFilePath := filepath.Join(tempDir, depNewPath)
	contentBytes, readErr := os.ReadFile(depNewFilePath)
	require.NoError(t, readErr, "Failed to read depNew file: %s", depNewFilePath)
	assert.Equal(t, depNewContent, string(contentBytes), "depNew file content mismatch")

	// 2. Verify almd-lock.toml is updated for depNew
	lockFilePath := filepath.Join(tempDir, lockfile.LockfileName)
	updatedLockCfg := readAlmdLockToml(t, lockFilePath)

	require.NotNil(t, updatedLockCfg.Package, "Packages map in almd-lock.toml is nil")
	depNewLockEntry, ok := updatedLockCfg.Package[depNewName]
	require.True(t, ok, "depNew entry not found in almd-lock.toml after install")

	expectedLockSourceURL := mockServer.URL + rawDownloadPathDepNew
	assert.Equal(t, expectedLockSourceURL, depNewLockEntry.Source, "depNew lockfile source URL mismatch")
	assert.Equal(t, depNewPath, depNewLockEntry.Path, "depNew lockfile path mismatch")
	assert.Equal(t, "commit:"+depNewCommitSHA, depNewLockEntry.Hash, "depNew lockfile hash mismatch")
}

// Task 7.2.5: Test `almd install` - Local dependency file missing
func TestInstallCommand_LocalFileMissing(t *testing.T) {
	depAName := "depA"
	depAPath := "libs/depA.lua"
	depAContent := "local depA_content_from_lock = true"      // Content served if lockfile's version is fetched
	depALockedCommitSHA := "fedcba0987654321fedcba0987654321" // Valid hex

	initialProjectToml := fmt.Sprintf(`
[package]
name = "test-local-file-missing"
version = "0.1.0"

[dependencies.%s]
source = "github:testowner/testrepo/%s@main" # 'main' might resolve to the same or different commit
path = "%s"
`, depAName, depAPath, depAPath)

	// Lockfile has depA, but its local file will be missing
	initialLockfile := fmt.Sprintf(`
api_version = "1"

[package.%s]
source = "https://raw.githubusercontent.com/testowner/testrepo/%s/%s" # URL with locked SHA
path = "%s"
hash = "commit:%s"
`, depAName, depALockedCommitSHA, depAPath, depAPath, depALockedCommitSHA)

	// No mock files initially for depA, simulating it's missing
	tempDir := setupInstallTestEnvironment(t, initialProjectToml, initialLockfile, nil)

	// Mock server setup
	// Case 1: 'main' in project.toml resolves to the *same* commit as in lockfile.
	// The install logic should then use the lockfile's source URL to re-download.
	githubAPIPathForDepA := fmt.Sprintf("/repos/testowner/testrepo/commits?path=%s&sha=main&per_page=1", depAPath)
	githubAPIResponseForDepA := fmt.Sprintf(`[{"sha": "%s"}]`, depALockedCommitSHA) // 'main' resolves to the locked SHA

	// Raw download path for depA using the locked commit SHA (from lockfile's source or resolved from project.toml)
	rawDownloadPathDepA := fmt.Sprintf("/testowner/testrepo/%s/%s", depALockedCommitSHA, depAPath)

	pathResps := map[string]struct {
		Body string
		Code int
	}{
		githubAPIPathForDepA: {Body: githubAPIResponseForDepA, Code: http.StatusOK},
		rawDownloadPathDepA:  {Body: depAContent, Code: http.StatusOK}, // Content for the locked SHA
	}
	mockServer := startMockHTTPServer(t, pathResps)

	originalGHAPIBaseURL := source.GithubAPIBaseURL
	source.GithubAPIBaseURL = mockServer.URL
	defer func() { source.GithubAPIBaseURL = originalGHAPIBaseURL }()

	// --- Run Command for depA ---
	err := runInstallCommand(t, tempDir, depAName)
	require.NoError(t, err, "almd install %s command failed", depAName)

	// --- Assertions ---
	// 1. Verify depA file is re-downloaded
	depAFilePath := filepath.Join(tempDir, depAPath)
	contentBytes, readErr := os.ReadFile(depAFilePath)
	require.NoError(t, readErr, "Failed to read re-downloaded depA file: %s", depAFilePath)
	assert.Equal(t, depAContent, string(contentBytes), "depA file content mismatch after re-download")

	// 2. Verify almd-lock.toml entry for depA is still correct (or updated if project.toml dictated newer)
	// In this test, since 'main' resolved to the same locked SHA, the lockfile entry should effectively be the same.
	lockFilePath := filepath.Join(tempDir, lockfile.LockfileName)
	updatedLockCfg := readAlmdLockToml(t, lockFilePath)

	require.NotNil(t, updatedLockCfg.Package, "Packages map in almd-lock.toml is nil")
	depALockEntry, ok := updatedLockCfg.Package[depAName]
	require.True(t, ok, "depA entry not found in almd-lock.toml after install")

	// Expected raw source URL in lockfile should point to the mock server's path for the locked commit
	expectedLockSourceURL := mockServer.URL + rawDownloadPathDepA
	assert.Equal(t, expectedLockSourceURL, depALockEntry.Source, "depA lockfile source URL mismatch")
	assert.Equal(t, depAPath, depALockEntry.Path, "depA lockfile path mismatch")
	assert.Equal(t, "commit:"+depALockedCommitSHA, depALockEntry.Hash, "depA lockfile hash mismatch")
}

// Task 7.2.6: Test `almd install --force` - Force install on an up-to-date dependency
func TestInstallCommand_ForceInstallUpToDateDependency(t *testing.T) {
	depAName := "depA"
	depAPath := "libs/depA.lua"
	depAContent := "local depA_v_current = true"
	depACommitCurrentSHA := "a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2" // Valid 40-char hex

	initialProjectToml := fmt.Sprintf(`
[package]
name = "test-force-install-project"
version = "0.1.0"

[dependencies.%s]
source = "github:testowner/testrepo/%s@main"
path = "%s"
`, depAName, depAPath, depAPath)

	// Lockfile points to the current commit, and local file matches this version
	initialLockfileContent := fmt.Sprintf(`
api_version = "1"

[package.%s]
source = "https://raw.githubusercontent.com/testowner/testrepo/%s/%s"
path = "%s"
hash = "commit:%s"
`, depAName, depACommitCurrentSHA, depAPath, depAPath, depACommitCurrentSHA)

	mockFiles := map[string]string{
		depAPath: depAContent, // Local file exists and is "current"
	}

	tempDir := setupInstallTestEnvironment(t, initialProjectToml, initialLockfileContent, mockFiles)

	// Mock server setup
	// GitHub API call to resolve 'main' for depA should return the *same* current SHA
	githubAPIPathForDepA := fmt.Sprintf("/repos/testowner/testrepo/commits?path=%s&sha=main&per_page=1", depAPath)
	githubAPIResponseForDepA := fmt.Sprintf(`[{"sha": "%s"}]`, depACommitCurrentSHA)

	// Raw download path - this *should* be called due to --force
	rawDownloadPathDepA := fmt.Sprintf("/testowner/testrepo/%s/%s", depACommitCurrentSHA, depAPath)

	// Keep track of whether the download endpoint was called
	downloadEndpointCalled := false
	pathResps := map[string]struct {
		Body string
		Code int
	}{
		githubAPIPathForDepA: {Body: githubAPIResponseForDepA, Code: http.StatusOK},
		rawDownloadPathDepA: {
			Body: depAContent, // Serve the same content, or new if we want to check content update
			Code: http.StatusOK,
		},
	}

	// Modify the server to track the call
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		requestPathWithQuery := r.URL.Path
		if r.URL.RawQuery != "" {
			requestPathWithQuery += "?" + r.URL.RawQuery
		}

		if r.Method == http.MethodGet && (r.URL.Path == rawDownloadPathDepA || requestPathWithQuery == rawDownloadPathDepA) {
			downloadEndpointCalled = true
		}

		for path, response := range pathResps {
			if r.Method == http.MethodGet && (r.URL.Path == path || requestPathWithQuery == path) {
				w.WriteHeader(response.Code)
				_, err := w.Write([]byte(response.Body))
				assert.NoError(t, err, "Mock server failed to write response body for path: %s", path)
				return
			}
		}
		t.Logf("Mock server: unexpected request: Method %s, Path %s, Query %s", r.Method, r.URL.Path, r.URL.RawQuery)
		http.NotFound(w, r)
	}))
	t.Cleanup(server.Close)
	mockServerURL := server.URL

	originalGHAPIBaseURL := source.GithubAPIBaseURL
	source.GithubAPIBaseURL = mockServerURL
	defer func() { source.GithubAPIBaseURL = originalGHAPIBaseURL }()

	// --- Run Command with --force ---
	// Note: urfave/cli parses flags before arguments.
	// So, `almd install depA --force` or `almd install --force depA` should work.
	// The task description uses `almd install --force depA`.
	err := runInstallCommand(t, tempDir, "--force", depAName)
	require.NoError(t, err, "almd install --force %s command failed", depAName)

	// --- Assertions ---
	assert.True(t, downloadEndpointCalled, "Download endpoint for depA was not called despite --force")

	// 1. Verify depA file content (could be same or updated if mock served new content)
	depAFilePath := filepath.Join(tempDir, depAPath)
	currentContentBytes, readErr := os.ReadFile(depAFilePath)
	require.NoError(t, readErr, "Failed to read depA file: %s", depAFilePath)
	assert.Equal(t, depAContent, string(currentContentBytes), "depA file content should be (re-)written")

	// 2. Verify almd-lock.toml is refreshed
	lockFilePath := filepath.Join(tempDir, lockfile.LockfileName)
	updatedLockCfg := readAlmdLockToml(t, lockFilePath)

	require.NotNil(t, updatedLockCfg.Package, "Packages map in almd-lock.toml is nil after force install")
	depALockEntry, ok := updatedLockCfg.Package[depAName]
	require.True(t, ok, "depA entry not found in almd-lock.toml after force install")

	expectedLockSourceURL := mockServerURL + rawDownloadPathDepA
	assert.Equal(t, expectedLockSourceURL, depALockEntry.Source, "depA lockfile source URL mismatch after force")
	assert.Equal(t, depAPath, depALockEntry.Path, "depA lockfile path mismatch after force")
	assert.Equal(t, "commit:"+depACommitCurrentSHA, depALockEntry.Hash, "depA lockfile hash mismatch after force (could be re-verified)")

	// 3. Verify project.toml remains unchanged
	projTomlPath := filepath.Join(tempDir, config.ProjectTomlName)
	currentProjCfg := readProjectToml(t, projTomlPath)
	originalProjCfg := project.Project{}
	errUnmarshalProj := toml.Unmarshal([]byte(initialProjectToml), &originalProjCfg)
	require.NoError(t, errUnmarshalProj, "Failed to unmarshal original project.toml content for comparison")
	assert.Equal(t, originalProjCfg, currentProjCfg, "project.toml should be unchanged after force install")
}

// Task 7.2.7: Test `almd install <non_existent_dep>` - Non-existent dependency specified
func TestInstallCommand_NonExistentDependencySpecified(t *testing.T) {
	nonExistentDepName := "nonExistentDep"

	initialProjectToml := `
[package]
name = "test-nonexistent-dep-project"
version = "0.1.0"
# No dependencies defined, or at least not nonExistentDep
`
	initialLockfileContent := `
api_version = "1"
[package]
`
	tempDir := setupInstallTestEnvironment(t, initialProjectToml, initialLockfileContent, nil)

	// No mock server needed as no downloads should occur for a non-existent dependency.

	// --- Run Command ---
	// We expect a warning, but the command itself might not return an error,
	// or it might return a specific error that indicates "not found but continued".
	// For now, we'll check that it doesn't panic and that files are unchanged.
	// Capturing stderr would be ideal for checking the warning.
	err := runInstallCommand(t, tempDir, nonExistentDepName)

	// Depending on implementation, this might be an error or not.
	// If it's just a warning, err might be nil.
	// For now, let's assume it might print a warning and continue without error if other deps were processed.
	// If only a non-existent dep is specified, it might still be a non-error exit.
	// The task says "Warning message printed, no other actions taken".
	// Let's assert no error for now, and focus on "no other actions taken".
	// If the command *does* return an error for this, this assertion will need adjustment.
	require.NoError(t, err, "almd install %s command failed unexpectedly (expected warning, not fatal error)", nonExistentDepName)

	// --- Assertions ---
	// 1. Verify project.toml remains unchanged
	projTomlPath := filepath.Join(tempDir, config.ProjectTomlName)
	currentProjCfg := readProjectToml(t, projTomlPath)
	originalProjCfg := project.Project{}
	errUnmarshalProj := toml.Unmarshal([]byte(initialProjectToml), &originalProjCfg)
	require.NoError(t, errUnmarshalProj, "Failed to unmarshal original project.toml content for comparison")
	assert.Equal(t, originalProjCfg, currentProjCfg, "project.toml should be unchanged")

	// 2. Verify almd-lock.toml remains unchanged
	lockFilePath := filepath.Join(tempDir, lockfile.LockfileName)
	currentLockCfg := readAlmdLockToml(t, lockFilePath)
	originalLockCfg := lockfile.Lockfile{}
	errUnmarshalLock := toml.Unmarshal([]byte(initialLockfileContent), &originalLockCfg)
	require.NoError(t, errUnmarshalLock, "Failed to unmarshal original lockfile content for comparison")
	assert.Equal(t, originalLockCfg, currentLockCfg, "almd-lock.toml should be unchanged")

	// 3. Verify no files were created in common dependency directories (e.g., libs, vendor)
	// This is a basic check; a more robust check would be to snapshot directory contents.
	libsDir := filepath.Join(tempDir, "libs")
	_, errStatLibs := os.Stat(libsDir)
	assert.True(t, os.IsNotExist(errStatLibs), "libs directory should not have been created")

	vendorDir := filepath.Join(tempDir, "vendor")
	_, errStatVendor := os.Stat(vendorDir)
	assert.True(t, os.IsNotExist(errStatVendor), "vendor directory should not have been created")

	// 4. Verify no file named nonExistentDep was created at root
	nonExistentDepFilePath := filepath.Join(tempDir, nonExistentDepName)
	_, errStatDepFile := os.Stat(nonExistentDepFilePath)
	assert.True(t, os.IsNotExist(errStatDepFile), "File for nonExistentDep should not have been created")
}

// Task 7.2.8: Test `almd install` - Error during download
func TestInstallCommand_ErrorDuringDownload(t *testing.T) {
	depName := "depWithError"
	depPath := "libs/depWithError.lua"
	depOriginalContent := "local depWithError_v1 = true"
	// depNewContent is not relevant as download will fail

	initialProjectToml := fmt.Sprintf(`
[package]
name = "test-download-error-project"
version = "0.1.0"

[dependencies.%s]
source = "github:testowner/testrepo/%s@main"
path = "%s"
`, depName, depPath, depPath)

	initialLockfile := fmt.Sprintf(`
api_version = "1"

[package.%s]
source = "https://raw.githubusercontent.com/testowner/testrepo/commit1_sha_dlerror/%s"
path = "%s"
hash = "commit:commit1_sha_dlerror"
`, depName, depPath, depPath)

	mockFiles := map[string]string{
		depPath: depOriginalContent,
	}

	tempDir := setupInstallTestEnvironment(t, initialProjectToml, initialLockfile, mockFiles)

	// Mock server setup
	commitToDownloadSHA := "commit2_sha_dlerror_target"
	githubAPIPathForDep := fmt.Sprintf("/repos/testowner/testrepo/commits?path=%s&sha=main&per_page=1", depPath)
	githubAPIResponseForDep := fmt.Sprintf(`[{"sha": "%s"}]`, commitToDownloadSHA)

	// This is the path that will fail
	rawDownloadPathDep := fmt.Sprintf("/testowner/testrepo/%s/%s", commitToDownloadSHA, depPath)

	pathResps := map[string]struct {
		Body string
		Code int
	}{
		githubAPIPathForDep: {Body: githubAPIResponseForDep, Code: http.StatusOK},
		rawDownloadPathDep:  {Body: "Simulated server error", Code: http.StatusInternalServerError}, // Download fails
	}
	mockServer := startMockHTTPServer(t, pathResps)

	originalGHAPIBaseURL := source.GithubAPIBaseURL
	source.GithubAPIBaseURL = mockServer.URL
	defer func() { source.GithubAPIBaseURL = originalGHAPIBaseURL }()

	// --- Run Command ---
	err := runInstallCommand(t, tempDir) // Install all
	require.Error(t, err, "almd install command should have failed due to download error")
	// Check for a more specific error if possible, e.g., by inspecting err.Error() or using cli.ExitCoder
	// For now, a general error check is fine. Example: assert.Contains(t, err.Error(), "failed to download")

	// --- Assertions ---
	// 1. Verify depWithError file content is UNCHANGED
	depFilePath := filepath.Join(tempDir, depPath)
	currentContentBytes, readErr := os.ReadFile(depFilePath)
	require.NoError(t, readErr, "Failed to read depWithError file: %s", depFilePath)
	assert.Equal(t, depOriginalContent, string(currentContentBytes), "depWithError file content should be unchanged after failed download")

	// 2. Verify almd-lock.toml is UNCHANGED
	lockFilePath := filepath.Join(tempDir, lockfile.LockfileName)
	currentLockCfg := readAlmdLockToml(t, lockFilePath)
	originalLockCfg := lockfile.Lockfile{}
	errUnmarshal := toml.Unmarshal([]byte(initialLockfile), &originalLockCfg)
	require.NoError(t, errUnmarshal, "Failed to unmarshal original lockfile content for comparison")
	assert.Equal(t, originalLockCfg, currentLockCfg, "almd-lock.toml should be unchanged after failed download")

	// 3. Verify project.toml remains unchanged
	projTomlPath := filepath.Join(tempDir, config.ProjectTomlName)
	currentProjCfg := readProjectToml(t, projTomlPath)
	originalProjCfg := project.Project{}
	errUnmarshalProj := toml.Unmarshal([]byte(initialProjectToml), &originalProjCfg)
	require.NoError(t, errUnmarshalProj, "Failed to unmarshal original project.toml content for comparison")
	assert.Equal(t, originalProjCfg, currentProjCfg, "project.toml should be unchanged")
}

// Task 7.2.9: Test `almd install` - Error during source resolution (e.g., branch not found)
func TestInstallCommand_ErrorDuringSourceResolution(t *testing.T) {
	depName := "depBadBranch"
	depPath := "libs/depBadBranch.lua"
	nonExistentBranch := "nonexistent_branch_for_sure"

	initialProjectToml := fmt.Sprintf(`
[package]
name = "test-source-resolution-error-project"
version = "0.1.0"

[dependencies.%s]
source = "github:testowner/testrepo/%s@%s"
path = "%s"
`, depName, depPath, nonExistentBranch, depPath) // Points to a non-existent branch

	// Lockfile might be empty or not contain this dep, or contain an old version.
	// The key is that resolution for the project.toml source will fail.
	initialLockfile := `
api_version = "1"
[package]
`
	// No initial mock file for depBadBranch as it shouldn't be downloaded.
	tempDir := setupInstallTestEnvironment(t, initialProjectToml, initialLockfile, nil)

	// Mock server setup
	// The GitHub API call to resolve 'nonexistent_branch_for_sure' should fail (e.g., 404 or empty array)
	githubAPIPathForDep := fmt.Sprintf("/repos/testowner/testrepo/commits?path=%s&sha=%s&per_page=1", depPath, nonExistentBranch)
	// GitHub API returns an empty array `[]` for a branch that doesn't exist or has no commits for that path.
	// Or it could be a 422 if the ref is malformed, or 404 if repo/owner is wrong.
	// For a non-existent branch, an empty array is a common valid JSON response.
	// The source resolver should interpret this as "commit not found".
	githubAPIResponseForDep_NotFound := `[]` // Simulates branch not found / no commits for path on branch

	// Raw download path - should NOT be called
	rawDownloadPathDep := fmt.Sprintf("/testowner/testrepo/some_sha_never_reached/%s", depPath)

	pathResps := map[string]struct {
		Body string
		Code int
	}{
		// This API call will "succeed" with an empty list, indicating no commit found for the ref.
		githubAPIPathForDep: {Body: githubAPIResponseForDep_NotFound, Code: http.StatusOK},
		// This should not be called
		rawDownloadPathDep: {Body: "SHOULD NOT BE DOWNLOADED", Code: http.StatusOK},
	}
	mockServer := startMockHTTPServer(t, pathResps)

	originalGHAPIBaseURL := source.GithubAPIBaseURL
	source.GithubAPIBaseURL = mockServer.URL
	defer func() { source.GithubAPIBaseURL = originalGHAPIBaseURL }()

	// --- Run Command ---
	// We can run for all, or specifically for depName. The error should propagate.
	err := runInstallCommand(t, tempDir, depName)
	require.Error(t, err, "almd install command should have failed due to source resolution error")
	// Example: assert.Contains(t, err.Error(), "failed to resolve source")
	// Example: assert.Contains(t, err.Error(), depName) // Error message should mention the problematic dependency

	// --- Assertions ---
	// 1. Verify depBadBranch file is NOT created
	depFilePath := filepath.Join(tempDir, depPath)
	_, statErr := os.Stat(depFilePath)
	assert.True(t, os.IsNotExist(statErr), "depBadBranch file should not have been created")

	// 2. Verify almd-lock.toml is UNCHANGED (or remains in its initial state)
	lockFilePath := filepath.Join(tempDir, lockfile.LockfileName)
	currentLockCfg := readAlmdLockToml(t, lockFilePath) // Read current
	originalLockCfg := lockfile.Lockfile{}              // For comparison
	errUnmarshal := toml.Unmarshal([]byte(initialLockfile), &originalLockCfg)
	require.NoError(t, errUnmarshal, "Failed to unmarshal original lockfile content for comparison")
	assert.Equal(t, originalLockCfg, currentLockCfg, "almd-lock.toml should be unchanged after source resolution error")

	// 3. Verify project.toml remains unchanged
	projTomlPath := filepath.Join(tempDir, config.ProjectTomlName)
	currentProjCfg := readProjectToml(t, projTomlPath)
	originalProjCfg := project.Project{}
	errUnmarshalProj := toml.Unmarshal([]byte(initialProjectToml), &originalProjCfg)
	require.NoError(t, errUnmarshalProj, "Failed to unmarshal original project.toml content for comparison")
	assert.Equal(t, originalProjCfg, currentProjCfg, "project.toml should be unchanged")
}

// Task 7.2.10: Test `almd install` - `project.toml` not found
func TestInstallCommand_ProjectTomlNotFound(t *testing.T) {
	// Setup: Create a temp directory but do NOT create project.toml
	tempDir := setupInstallTestEnvironment(t, "", "", nil) // Empty string for projectTomlContent

	// --- Run Command ---
	// Expect an error because project.toml is missing
	err := runInstallCommand(t, tempDir)

	// --- Assertions ---
	// 1. Verify command returns an error
	require.Error(t, err, "almd install should return an error when project.toml is not found")

	// 2. Verify the error message indicates project.toml was not found
	//    The exact message depends on how internal/core/config.LoadProjectToml and the install command handle this.
	//    Common error messages include "no such file or directory" or a custom "project.toml not found".
	//    Let's check for a substring that is likely to be present.
	//    Based on typical os.ReadFile errors or custom errors from config loading.
	assert.Contains(t, err.Error(), config.ProjectTomlName, "Error message should mention project.toml")
	assert.Contains(t, err.Error(), "not found in the current directory", "Error message should indicate file not found in current directory")
}



================================================
File: internal/cli/list/list.go
================================================
package list

import (
	"fmt"
	"os"

	"github.com/fatih/color"
	"github.com/urfave/cli/v2"

	"github.com/nightconcept/almandine-go/internal/core/config"
	"github.com/nightconcept/almandine-go/internal/core/lockfile"
	// Assuming project root for project.toml and almd-lock.toml
)

// dependencyDisplayInfo holds all information needed for displaying a dependency.
type dependencyDisplayInfo struct {
	Name           string
	ProjectSource  string
	ProjectPath    string
	LockedSource   string
	LockedHash     string
	FileExists     bool
	IsLocked       bool   // Indicates if an entry exists in the lockfile
	FileStatusInfo string // Additional info like "missing", "not locked"
}

// ListCmd defines the structure for the 'list' command.
var ListCmd = &cli.Command{
	Name:    "list",
	Aliases: []string{"ls"},
	Usage:   "Displays project dependencies and their status.",
	Action: func(c *cli.Context) error {
		projectTomlPath := "project.toml" // This is relative to CWD, LoadProjectToml expects root

		proj, err := config.LoadProjectToml(".")
		if err != nil {
			if os.IsNotExist(err) {
				// Return an error that the test can catch, consistent with other error exits.
				// The test TestListCommand_ProjectTomlNotFound expects an error.
				return cli.Exit(fmt.Sprintf("Error: %s not found. No project configuration loaded.", projectTomlPath), 1)
			}
			// For other errors during loading
			return cli.Exit(fmt.Sprintf("Error loading %s: %v", projectTomlPath, err), 1)
		}

		lf, err := lockfile.Load(".")
		if err != nil {
			// lockfile.Load handles "not found" by returning a new lf and no error.
			// Any error here is likely a more serious issue.
			return cli.Exit(fmt.Sprintf("Error loading %s: %v", lockfile.LockfileName, err), 1)
		}
		// Ensure lf is not nil, though lockfile.Load should guarantee this if err is nil.
		if lf == nil {
			lf = lockfile.New()
		}

		var displayDeps []dependencyDisplayInfo

		// Display project information
		// Get current working directory for display, or use a placeholder if error
		wd, err := os.Getwd()
		if err != nil {
			wd = "." // Default to current directory symbol if error
		}

		// Updated Color definitions (Task 10.1, User Feedback)
		projectNameColor := color.New(color.FgMagenta, color.Bold, color.Underline).SprintFunc()
		projectVersionColor := color.New(color.FgMagenta).SprintFunc() // Version not specified for bold/underline
		projectPathColor := color.New(color.FgHiBlack, color.Bold, color.Underline).SprintFunc()
		dependenciesHeaderColor := color.New(color.FgCyan, color.Bold).SprintFunc()
		depNameColor := color.New(color.FgYellow).SprintFunc()
		// depHashColor will use standard terminal color, so no specific SprintFunc needed for it unless we want to force reset.
		// For explicit reset, you could use: color.New(color.Reset).SprintFunc()
		// However, fmt.Printf handles standard color naturally if no color func is applied.
		depPathColor := color.New(color.FgGreen).SprintFunc()
		// Standard color for "@"
		atStr := "@"

		fmt.Printf("%s%s%s %s\n", projectNameColor(proj.Package.Name), atStr, projectVersionColor(proj.Package.Version), projectPathColor(wd))
		fmt.Println() // Empty line

		if len(proj.Dependencies) == 0 {
			// Handle Task 8.5: No dependencies found
			fmt.Println(dependenciesHeaderColor("dependencies:")) // Still print the header
			// Task 8.5: If project.toml has no [dependencies] table or it's empty,
			// print an appropriate message.
			fmt.Println("No dependencies found in project.toml.")
			return nil
		}

		fmt.Println(dependenciesHeaderColor("dependencies:"))
		for name, depDetails := range proj.Dependencies {
			info := dependencyDisplayInfo{
				Name:          name,
				ProjectSource: depDetails.Source,
				ProjectPath:   depDetails.Path,
			}

			// Check lockfile
			if lockEntry, ok := lf.Package[name]; ok {
				info.IsLocked = true
				info.LockedSource = lockEntry.Source
				info.LockedHash = lockEntry.Hash
			} else {
				info.IsLocked = false
				info.FileStatusInfo = "not locked"
			}

			// Check file existence
			// project.toml paths are relative to the project root.
			// The CWD for `almd` execution is assumed to be the project root.
			if _, err := os.Stat(depDetails.Path); err == nil {
				info.FileExists = true
			} else if os.IsNotExist(err) {
				info.FileExists = false
				if info.FileStatusInfo != "" {
					info.FileStatusInfo += ", missing"
				} else {
					info.FileStatusInfo = "missing"
				}
			} else {
				// Other error (e.g., permission denied)
				info.FileExists = false
				if info.FileStatusInfo != "" {
					info.FileStatusInfo += ", error checking file"
				} else {
					info.FileStatusInfo = "error checking file"
				}
				fmt.Fprintf(os.Stderr, "Warning: could not check status of %s: %v\n", depDetails.Path, err)
			}
			displayDeps = append(displayDeps, info)
		}

		// Default Output Formatting (Task 8.4)
		// TODO: Add handling for --long, --json, --porcelain flags later based on PRD.
		// For now, implementing only the default format.

		// The earlier check for len(proj.Dependencies) == 0 handles the "no dependencies" case.
		// If we reach here, displayDeps should have items if proj.Dependencies had items.
		for _, dep := range displayDeps {
			lockedHash := "not locked"
			if dep.IsLocked && dep.LockedHash != "" {
				lockedHash = dep.LockedHash
			} else if dep.IsLocked && dep.LockedHash == "" {
				lockedHash = "locked (no hash)"
			}

			// New format: name path hash (Updated 2025-05-08)
			// Apply new colors: Dependency Name (Yellow), Path (Green), Hash (Standard)
			fmt.Printf("%s %s %s\n", depNameColor(dep.Name), depPathColor(dep.ProjectPath), lockedHash)
		}
		return nil
	},
}



================================================
File: internal/cli/list/list_test.go
================================================
package list

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/urfave/cli/v2"

	"github.com/nightconcept/almandine-go/internal/core/config"
	// "github.com/nightconcept/almandine-go/internal/core/project" // Will be needed when other tests are implemented
)

// setupListTestEnvironment creates a temporary directory with project.toml,
// almd-lock.toml, and optional dummy dependency files.
// It returns the path to the temporary directory.
func setupListTestEnvironment(t *testing.T, projectTomlContent string, lockfileContent string, depFiles map[string]string) string {
	t.Helper()
	tempDir := t.TempDir()

	if projectTomlContent != "" {
		projectTomlPath := filepath.Join(tempDir, config.ProjectTomlName)
		err := os.WriteFile(projectTomlPath, []byte(projectTomlContent), 0644)
		require.NoError(t, err, "Failed to write project.toml")
	}

	if lockfileContent != "" {
		lockfilePath := filepath.Join(tempDir, config.LockfileName)
		err := os.WriteFile(lockfilePath, []byte(lockfileContent), 0644)
		require.NoError(t, err, "Failed to write almd-lock.toml")
	}

	for relPath, content := range depFiles {
		absPath := filepath.Join(tempDir, relPath)
		err := os.MkdirAll(filepath.Dir(absPath), 0755)
		require.NoError(t, err, "Failed to create parent directory for dep file")
		err = os.WriteFile(absPath, []byte(content), 0644)
		require.NoError(t, err, "Failed to write dependency file")
	}

	return tempDir
}

// runListCommand executes the list command in the given testDir and captures its stdout.
// It changes the CWD to testDir for the duration of the command execution.
func runListCommand(t *testing.T, testDir string, appArgs ...string) (string, error) {
	t.Helper()

	originalStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	originalWD, err := os.Getwd()
	require.NoError(t, err, "Failed to get current working directory")

	err = os.Chdir(testDir)
	require.NoError(t, err, "Failed to change working directory to testDir")

	defer func() {
		os.Stdout = originalStdout
		err := os.Chdir(originalWD)
		if err != nil {
			// Log or handle error if changing back directory fails
			fmt.Fprintf(os.Stderr, "Error changing back to original directory: %v\n", err)
		}
		_ = r.Close() // Close read end of pipe
		_ = w.Close() // Close write end of pipe
	}()

	app := &cli.App{
		Commands: []*cli.Command{
			ListCmd, // Assumes ListCmd is defined in the current 'list' package
		},
		// Prevent os.Exit from being called by urfave/cli during tests
		ExitErrHandler: func(context *cli.Context, err error) {
			if err != nil {
				// This handler is primarily to prevent os.Exit.
				// Actual errors from app.Run are caught by cmdErr.
				fmt.Fprintf(os.Stderr, "Note: cli.ExitErrHandler caught error (expected for tests): %v\n", err)
			}
		},
	}
	fullArgs := []string{"almd"}
	fullArgs = append(fullArgs, appArgs...)

	// Disable color output for consistent test results
	t.Setenv("NO_COLOR", "1")

	cmdErr := app.Run(fullArgs)

	err = w.Close() // Close writer to flush buffer before reading
	if err != nil {
		// It's possible the pipe is already closed by app.Run, especially on error.
		// This is often a "write on closed pipe" or similar, which is expected in some error cases.
		// We log it for debugging but don't fail the test solely on this.
		fmt.Fprintf(os.Stderr, "Note: Error closing pipe writer (often expected on app error): %v\n", err)
	}

	var outBuf bytes.Buffer
	_, readErr := outBuf.ReadFrom(r)
	if readErr != nil && readErr.Error() != "io: read/write on closed pipe" {
		// Only assert if it's not the expected pipe closed error
		require.NoError(t, readErr, "Failed to read from stdout pipe")
	}

	return outBuf.String(), cmdErr
}

// TestListCommand_NoDependencies tests the `almd list` command when there are no dependencies.
func TestListCommand_NoDependencies(t *testing.T) {
	t.Run("project.toml exists but is empty", func(t *testing.T) {
		projectTomlContent := `
[package]
name = "test-project"
version = "0.1.0"
description = "A test project."
license = "MIT"
`
		tempDir := setupListTestEnvironment(t, projectTomlContent, "", nil)
		output, err := runListCommand(t, tempDir, "list")

		require.NoError(t, err)
		assert.Contains(t, output, "test-project@0.1.0")
		assert.Contains(t, output, tempDir) // Project path
		assert.Contains(t, output, "dependencies:")
		// Check that there are no dependency lines after "dependencies:"
		// This is a bit fragile, depends on exact output format.
		// A more robust check might parse the output or look for absence of typical dep lines.
		lines := strings.Split(strings.TrimSpace(output), "\n")
		depHeaderIndex := -1
		for i, line := range lines {
			if strings.Contains(line, "dependencies:") {
				depHeaderIndex = i
				break
			}
		}
		require.NotEqual(t, -1, depHeaderIndex, "Dependencies header not found")
		// Ensure no lines follow that look like dependency entries
		// For now, we assume if "No dependencies found" is NOT there, and header is, it's an empty list.
		// The actual list.go prints project info then "dependencies:", then items.
		// If no items, it just prints the header.
		// With the changes in list.go, this case (project.toml exists, package info present, but no [dependencies] table or it's empty)
		// should now print "No dependencies found in project.toml."
		assert.Contains(t, output, "No dependencies found in project.toml.", "Expected 'No dependencies found' message")
	})

	t.Run("project.toml with empty dependencies table", func(t *testing.T) {
		projectTomlContent := `
[package]
name = "test-project-empty-deps"
version = "0.1.0"
description = "A test project."
license = "MIT"

[dependencies]
`
		tempDir := setupListTestEnvironment(t, projectTomlContent, "", nil)
		output, err := runListCommand(t, tempDir, "list")

		require.NoError(t, err)
		assert.Contains(t, output, "test-project-empty-deps@0.1.0")
		assert.Contains(t, output, tempDir)
		assert.Contains(t, output, "dependencies:")
		// The "No dependencies found in project.toml." message is shown by printNoDependenciesMessage
		// which is called if proj.Dependencies is nil or len(proj.Dependencies) == 0
		// This seems to be the expected output from list.go's current logic.
		assert.Contains(t, output, "No dependencies found in project.toml.")
	})

	t.Run("project.toml with no dependencies table", func(t *testing.T) {
		// This is effectively the same as the first sub-test "project.toml exists but is empty"
		// if "empty" means no [dependencies] table.
		// The list command loads the project, and if project.Dependencies is nil, it triggers the "No dependencies" message.
		projectTomlContent := `
[package]
name = "test-project-no-deps-table"
version = "0.1.0"
`
		tempDir := setupListTestEnvironment(t, projectTomlContent, "", nil)
		output, err := runListCommand(t, tempDir, "list")

		require.NoError(t, err)
		assert.Contains(t, output, "test-project-no-deps-table@0.1.0")
		assert.Contains(t, output, tempDir)
		assert.Contains(t, output, "dependencies:") // Header is always printed
		assert.Contains(t, output, "No dependencies found in project.toml.")
	})
}

// TestListCommand_ProjectTomlNotFound tests `almd list` when project.toml is missing.
// This is a separate test as per typical Go test structure.
func TestListCommand_ProjectTomlNotFound(t *testing.T) {
	tempDir := t.TempDir() // Create an empty temp directory

	// Ensure NO_COLOR is set for consistent error message format if colors are used there too
	t.Setenv("NO_COLOR", "1")

	_, err := runListCommand(t, tempDir, "list")

	require.Error(t, err, "Expected an error when project.toml is not found")
	// Error message comes from internal/cli/list/list.go, from loadProjectAndLockfile
	// It should be something like "Error loading project.toml: open project.toml: no such file or directory"
	// The exact error message might be wrapped by urfave/cli.
	// Let's check the output for the core part of the error.
	// The actual error returned by app.Run might be a cli.ExitCoder.
	// The error message from cli.Exit is returned as an error that implements cli.ExitCoder.
	// Its Error() method gives the message.
	// urfave/cli prints this message to os.Stderr, not os.Stdout (which `output` captures).
	require.NotNil(t, err)
	assert.Contains(t, err.Error(), "Error: project.toml not found. No project configuration loaded.")
}

// Placeholder for future tests from Task 9.2.x
func TestListCommand_SingleDependency(t *testing.T) {
	// TODO: Implement Sub-Task 9.2.2
	t.Skip("TODO: Implement Sub-Task 9.2.2: Test almd list - Single dependency (fully installed and locked)")
}

func TestListCommand_MultipleDependenciesVariedStates(t *testing.T) {
	// TODO: Implement Sub-Task 9.2.3
	t.Skip("TODO: Implement Sub-Task 9.2.3: Test almd list - Multiple dependencies with varied states")
}

func TestListCommand_AliasLs(t *testing.T) {
	// TODO: Implement Sub-Task 9.2.4
	t.Skip("TODO: Implement Sub-Task 9.2.4: Test almd ls (alias) - Verify alias works")
}

// Note: Task 9.2.5 "project.toml not found" is covered by TestListCommand_ProjectTomlNotFound

// Helper to get project details from project.toml for assertions
/*
func getProjectDetails(t *testing.T, projectTomlPath string) (name, version string) {
	t.Helper()
	proj, err := config.LoadProjectToml(filepath.Dir(projectTomlPath))
	require.NoError(t, err, "Failed to load project.toml for details")
	require.NotNil(t, proj.Package, "Project package section is nil")
	return proj.Package.Name, proj.Package.Version
}
*/



================================================
File: internal/cli/remove/remove.go
================================================
package remove

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/nightconcept/almandine-go/internal/core/config"
	"github.com/nightconcept/almandine-go/internal/core/lockfile"
	"github.com/urfave/cli/v2"
)

// isDirEmpty checks if a directory is empty.
// It returns true if the directory has no entries, false otherwise.
// An error is returned if the directory cannot be read.
func isDirEmpty(path string) (bool, error) {
	entries, err := os.ReadDir(path)
	if err != nil {
		return false, fmt.Errorf("failed to read directory %s: %w", path, err)
	}
	return len(entries) == 0, nil
}

// RemoveCommand defines the structure for the 'remove' CLI command.
func RemoveCommand() *cli.Command {
	return &cli.Command{
		Name:      "remove",
		Usage:     "Remove a dependency from the project",
		ArgsUsage: "DEPENDENCY",
		Action: func(c *cli.Context) error {
			if !c.Args().Present() {
				return fmt.Errorf("dependency name is required")
			}

			depName := c.Args().First()

			// Load project.toml from the current directory
			proj, err := config.LoadProjectToml(".")
			if err != nil {
				// config.LoadProjectToml will return an error if project.toml is not found or unreadable
				// os.IsNotExist check might be too specific if LoadProjectToml wraps errors.
				// A more general check for err != nil is better here.
				// The error from LoadProjectToml should be descriptive enough.
				return cli.Exit(fmt.Sprintf("Error: Failed to load %s: %v", config.ProjectTomlName, err), 1)
			}

			if len(proj.Dependencies) == 0 {
				return cli.Exit(fmt.Sprintf("Error: No dependencies found in %s.", config.ProjectTomlName), 1)
			}

			dep, ok := proj.Dependencies[depName]
			if !ok {
				return cli.Exit(fmt.Sprintf("Error: Dependency '%s' not found in %s.", depName, config.ProjectTomlName), 1)
			}

			dependencyPath := dep.Path
			// Remove the dependency from the manifest
			delete(proj.Dependencies, depName)

			// Save the updated manifest
			if err := config.WriteProjectToml(".", proj); err != nil {
				return cli.Exit(fmt.Sprintf("Error: Failed to update %s: %v", config.ProjectTomlName, err), 1)
			}
			fmt.Printf("Successfully removed dependency '%s' from %s.\n", depName, config.ProjectTomlName)

			// Delete the dependency file
			if err := os.Remove(dependencyPath); err != nil {
				// If the file is already gone, it's not a critical error for the remove operation's main goal (manifest update).
				// However, other errors (like permission issues) should be reported.
				if !os.IsNotExist(err) {
					return cli.Exit(fmt.Sprintf("Error: Failed to delete dependency file '%s': %v. Manifest updated.", dependencyPath, err), 1)
				}
				fmt.Printf("Warning: Dependency file '%s' not found for deletion, but manifest updated.\n", dependencyPath)
			} else {
				fmt.Printf("Successfully deleted dependency file '%s'.\n", dependencyPath)

				// Attempt to clean up empty parent directories
				currentDir := filepath.Dir(dependencyPath)
				projectRootAbs, err := filepath.Abs(".")
				if err != nil {
					fmt.Printf("Warning: Could not determine project root absolute path: %v. Skipping directory cleanup.\n", err)
				} else {
					for {
						absCurrentDir, err := filepath.Abs(currentDir)
						if err != nil {
							fmt.Printf("Warning: Could not get absolute path for '%s': %v. Stopping directory cleanup.\n", currentDir, err)
							break
						}

						// Stop conditions:
						// 1. Reached project root
						// 2. Reached a filesystem root (e.g., "/" or "C:\")
						// 3. Current directory is "." (already at project root relative)
						if absCurrentDir == projectRootAbs || filepath.Dir(absCurrentDir) == absCurrentDir || currentDir == "." {
							break
						}

						empty, err := isDirEmpty(currentDir)
						if err != nil {
							fmt.Printf("Warning: Could not check if directory '%s' is empty: %v. Stopping directory cleanup.\n", currentDir, err)
							break
						}

						if !empty {
							// Directory is not empty, so stop
							break
						}

						// Directory is empty, try to remove it
						fmt.Printf("Info: Directory '%s' is empty, attempting to remove.\n", currentDir)
						if err := os.Remove(currentDir); err != nil {
							fmt.Printf("Warning: Failed to remove empty directory '%s': %v. Stopping directory cleanup.\n", currentDir, err)
							break // Stop if removal fails (e.g., permissions)
						}
						fmt.Printf("Successfully removed empty directory '%s'.\n", currentDir)

						// Move to parent directory
						currentDir = filepath.Dir(currentDir)
					}
				}
			}

			// Update lockfile
			lf, err := lockfile.Load(".") // Load from current directory
			if err != nil {
				// If lockfile loading fails, it's not a critical error that should stop the command,
				// as manifest and file are already handled. Report as warning.
				fmt.Printf("Warning: Failed to load %s: %v. Manifest and file processed.\n", lockfile.LockfileName, err)
			} else {
				if lf.Package != nil {
					if _, ok := lf.Package[depName]; ok {
						delete(lf.Package, depName)
						if err := lockfile.Save(".", lf); err != nil {
							fmt.Printf("Warning: Failed to update %s: %v. Manifest and file processed.\n", lockfile.LockfileName, err)
						} else {
							fmt.Printf("Successfully removed dependency '%s' from %s.\n", depName, lockfile.LockfileName)
						}
					} else {
						fmt.Printf("Info: Dependency '%s' not found in %s. No changes made to lockfile.\n", depName, lockfile.LockfileName)
					}
				} else {
					fmt.Printf("Info: No 'package' section found in %s. No changes made to lockfile.\n", lockfile.LockfileName)
				}
			}

			fmt.Printf("Successfully removed dependency '%s'.\n", depName)
			return nil
		},
	}
}



================================================
File: internal/cli/remove/remove_test.go
================================================
package remove

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/BurntSushi/toml"
	"github.com/nightconcept/almandine-go/internal/core/config"
	"github.com/nightconcept/almandine-go/internal/core/lockfile"
	"github.com/nightconcept/almandine-go/internal/core/project" // Added import
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/urfave/cli/v2"
)

func TestRemoveCommand_SuccessfulRemoval(t *testing.T) {
	// Store original working directory and restore it after test
	originalWd, err := os.Getwd()
	t.Logf("Test starting in directory: %s", originalWd)
	require.NoError(t, err, "Failed to get current working directory")
	defer func() {
		t.Logf("Test cleanup: restoring directory to %s", originalWd)
		require.NoError(t, os.Chdir(originalWd), "Failed to restore original working directory")
	}()

	// Create initial project.toml content
	projectToml := `
[package]
name = "test-project"
version = "0.1.0"

[dependencies]
testlib = { source = "github:user/repo/file.lua@abc123", path = "libs/testlib.lua" }
`

	// Create initial lockfile content
	lockToml := `
api_version = "1"

[package.testlib]
source = "https://raw.githubusercontent.com/user/repo/abc123/file.lua"
path = "libs/testlib.lua"
hash = "sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
`

	// Create map of dependency files to create
	depFiles := map[string]string{
		"libs/testlib.lua": "-- Test dependency content",
	}

	// Set up test environment
	tempDir := setupRemoveTestEnvironment(t, projectToml, lockToml, depFiles)

	// After setup, verify files exist
	if _, err := os.Stat(filepath.Join(tempDir, "project.toml")); err != nil {
		t.Logf("After setup - project.toml status: %v", err)
	} else {
		t.Log("After setup - project.toml exists")
	}

	// Change to temp directory before running the test
	err = os.Chdir(tempDir)
	t.Logf("Changed to temp directory: %s", tempDir)
	require.NoError(t, err, "Failed to change to temporary directory")

	// Run the remove command
	err = runRemoveCommand(t, tempDir, "testlib")
	require.NoError(t, err)

	// Verify project.toml no longer contains the dependency
	projContent, err := os.ReadFile(filepath.Join(tempDir, "project.toml"))
	require.NoError(t, err)
	assert.NotContains(t, string(projContent), "testlib")

	// Parse project.toml to verify dependency is gone
	var proj struct {
		Dependencies map[string]interface{} `toml:"dependencies"`
	}
	err = toml.Unmarshal(projContent, &proj)
	require.NoError(t, err)
	assert.NotContains(t, proj.Dependencies, "testlib")

	// Verify almd-lock.toml no longer contains the dependency
	lockContent, err := os.ReadFile(filepath.Join(tempDir, "almd-lock.toml"))
	require.NoError(t, err)
	assert.NotContains(t, string(lockContent), "testlib")

	// Parse lock file to verify dependency is gone
	var lock struct {
		Package map[string]interface{} `toml:"package"`
	}
	err = toml.Unmarshal(lockContent, &lock)
	require.NoError(t, err)
	assert.NotContains(t, lock.Package, "testlib")

	// Verify dependency file is deleted
	_, err = os.Stat(filepath.Join(tempDir, "libs", "testlib.lua"))
	assert.True(t, os.IsNotExist(err), "Dependency file should be deleted")

	// Verify libs directory is removed (since it should be empty now)
	_, err = os.Stat(filepath.Join(tempDir, "libs"))
	assert.True(t, os.IsNotExist(err), "Empty libs directory should be removed")
}

func TestRemove_DependencyNotFound(t *testing.T) {
	// Store original working directory
	originalWd, err := os.Getwd()
	t.Logf("Test starting in directory: %s", originalWd)
	require.NoError(t, err, "Failed to get current working directory")
	defer func() {
		t.Logf("Test cleanup: restoring directory to %s", originalWd)
		require.NoError(t, os.Chdir(originalWd), "Failed to restore original working directory")
	}()

	// Create a temp dir for the test
	tempDir := t.TempDir()

	// Create a project.toml without the dependency we'll try to remove
	projectToml := `
[package]
name = "test-project"
version = "0.1.0"

[dependencies]
existing-dep = { source = "github:user/repo/file.lua", path = "libs/existing-dep.lua" }
`
	err = os.WriteFile(filepath.Join(tempDir, "project.toml"), []byte(projectToml), 0644)
	require.NoError(t, err)

	// Create a lockfile that matches project.toml
	lockfileToml := `
api_version = "1"

[package.existing-dep]
source = "https://raw.githubusercontent.com/user/repo/main/file.lua"
path = "libs/existing-dep.lua"
hash = "sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
`
	err = os.WriteFile(filepath.Join(tempDir, "almd-lock.toml"), []byte(lockfileToml), 0644)
	require.NoError(t, err)

	// Create the existing dependency file to ensure we don't accidentally delete it
	existingDepDir := filepath.Join(tempDir, "libs")
	err = os.MkdirAll(existingDepDir, 0755)
	require.NoError(t, err)
	err = os.WriteFile(filepath.Join(existingDepDir, "existing-dep.lua"), []byte("-- test content"), 0644)
	require.NoError(t, err)

	// Change to temp directory before running command
	err = os.Chdir(tempDir)
	t.Logf("Changed to temp directory: %s", tempDir)
	require.NoError(t, err, "Failed to change to temporary directory")

	// Execute the remove command
	err = runRemoveCommand(t, tempDir, "non-existent-dep")

	// Verify expectations
	assert.Error(t, err)
	assert.Equal(t, "Error: Dependency 'non-existent-dep' not found in project.toml.", err.Error())
	assert.Equal(t, 1, err.(cli.ExitCoder).ExitCode())

	// Verify project.toml and almd-lock.toml remain unchanged
	currentProjectToml, err := os.ReadFile(filepath.Join(tempDir, "project.toml"))
	require.NoError(t, err)
	assert.Equal(t, string(projectToml), string(currentProjectToml))

	currentLockfileToml, err := os.ReadFile(filepath.Join(tempDir, "almd-lock.toml"))
	require.NoError(t, err)
	assert.Equal(t, string(lockfileToml), string(currentLockfileToml))

	// Verify the existing dependency file was not touched
	_, err = os.Stat(filepath.Join(existingDepDir, "existing-dep.lua"))
	assert.NoError(t, err, "existing dependency file should not be deleted")
}

func TestRemoveCommand_DepFileMissing_StillUpdatesManifests(t *testing.T) {
	originalWd, err := os.Getwd()
	require.NoError(t, err)
	defer func() {
		require.NoError(t, os.Chdir(originalWd))
	}()

	projectTomlContent := `
[package]
name = "test-project-missing-file"
version = "0.1.0"

[dependencies]
missinglib = { source = "github:user/repo/missing.lua@def456", path = "libs/missinglib.lua" }
anotherlib = { source = "github:user/repo/another.lua@ghi789", path = "libs/anotherlib.lua" }
`
	lockTomlContent := `
api_version = "1"

[package.missinglib]
source = "https://raw.githubusercontent.com/user/repo/def456/missing.lua"
path = "libs/missinglib.lua"
hash = "sha256:123"

[package.anotherlib]
source = "https://raw.githubusercontent.com/user/repo/ghi789/another.lua"
path = "libs/anotherlib.lua"
hash = "sha256:456"
`
	// Setup environment: Create project.toml and almd-lock.toml
	// but DO NOT create the actual 'missinglib.lua' file.
	// Only create 'anotherlib.lua' to ensure other files are not affected.
	depFilesToCreate := map[string]string{
		"libs/anotherlib.lua": "-- another lib content",
	}
	tempDir := setupRemoveTestEnvironment(t, projectTomlContent, lockTomlContent, depFilesToCreate)

	err = os.Chdir(tempDir)
	require.NoError(t, err, "Failed to change to temporary directory")

	// Run the remove command for 'missinglib'
	// This should not return an error that stops processing,
	// as remove.go handles os.IsNotExist for the file deletion.
	err = runRemoveCommand(t, tempDir, "missinglib")
	require.NoError(t, err, "runRemoveCommand should not return a fatal error when dep file is missing")

	// Verify project.toml is updated (missinglib removed, anotherlib remains)
	var projData struct {
		Dependencies map[string]project.Dependency `toml:"dependencies"`
	}
	projBytes, err := os.ReadFile(filepath.Join(tempDir, config.ProjectTomlName))
	require.NoError(t, err)
	err = toml.Unmarshal(projBytes, &projData)
	require.NoError(t, err)
	assert.NotContains(t, projData.Dependencies, "missinglib", "missinglib should be removed from project.toml")
	assert.Contains(t, projData.Dependencies, "anotherlib", "anotherlib should still exist in project.toml")

	// Verify almd-lock.toml is updated (missinglib removed, anotherlib remains)
	var lockData struct {
		Package map[string]lockfile.PackageEntry `toml:"package"`
	}
	lockBytes, err := os.ReadFile(filepath.Join(tempDir, lockfile.LockfileName))
	require.NoError(t, err)
	err = toml.Unmarshal(lockBytes, &lockData)
	require.NoError(t, err)
	assert.NotContains(t, lockData.Package, "missinglib", "missinglib should be removed from almd-lock.toml")
	assert.Contains(t, lockData.Package, "anotherlib", "anotherlib should still exist in almd-lock.toml")

	// Verify the 'anotherlib.lua' file still exists
	_, err = os.Stat(filepath.Join(tempDir, "libs", "anotherlib.lua"))
	assert.NoError(t, err, "anotherlib.lua should still exist")

	// Verify 'missinglib.lua' (which never existed) is still not there
	_, err = os.Stat(filepath.Join(tempDir, "libs", "missinglib.lua"))
	assert.True(t, os.IsNotExist(err), "missinglib.lua should not exist")
}

func TestRemoveCommand_ProjectTomlNotFound(t *testing.T) {
	originalWd, err := os.Getwd()
	require.NoError(t, err, "Failed to get current working directory")
	defer func() {
		require.NoError(t, os.Chdir(originalWd), "Failed to restore original working directory")
	}()

	tempDir := t.TempDir()

	// Change to temp directory (which has no project.toml)
	err = os.Chdir(tempDir)
	require.NoError(t, err, "Failed to change to temporary directory: %s", tempDir)

	// Attempt to remove a dependency
	err = runRemoveCommand(t, tempDir, "any-dependency-name")

	// Verify the error
	require.Error(t, err, "Expected an error when project.toml is not found")

	// Check for cli.ExitCoder interface for specific exit code and message
	exitErr, ok := err.(cli.ExitCoder)
	require.True(t, ok, "Error should be a cli.ExitCoder")

	assert.Equal(t, 1, exitErr.ExitCode(), "Expected exit code 1")
	// Error message should now come from config.LoadProjectToml when project.toml is not found.
	// It will include the full path to project.toml.
	// We need to construct the expected full path for comparison.
	// expectedPath := filepath.Join(tempDir, config.ProjectTomlName) // No longer needed directly for constructing one single string
	// The actual error from os.ReadFile includes "open <path>: The system cannot find the file specified."
	// or similar OS-dependent message. We check if the error message *starts* with our expected prefix.
	assert.Contains(t, exitErr.Error(), "Error: Failed to load project.toml:", "Error message prefix mismatch")
	assert.Contains(t, exitErr.Error(), "cannot find the file specified", "Error message should indicate file not found")
}

func TestRemoveCommand_ManifestOnlyDependency(t *testing.T) {
	originalWd, err := os.Getwd()
	require.NoError(t, err)
	defer func() {
		require.NoError(t, os.Chdir(originalWd))
	}()

	projectTomlContent := `
[package]
name = "test-project-manifest-only"
version = "0.1.0"

[dependencies]
manifestonlylib = { source = "github:user/repo/manifestonly.lua@jkl012", path = "libs/manifestonlylib.lua" }
anotherlib = { source = "github:user/repo/another.lua@mno345", path = "libs/anotherlib.lua" }
`
	// Lockfile is empty or does not contain 'manifestonlylib'
	// It might contain other unrelated dependencies.
	lockTomlContent := `
api_version = "1"

[package.anotherlib]
source = "https://raw.githubusercontent.com/user/repo/mno345/another.lua"
path = "libs/anotherlib.lua"
hash = "sha256:789"
`
	depFilesToCreate := map[string]string{
		"libs/manifestonlylib.lua": "-- manifest only lib content",
		"libs/anotherlib.lua":      "-- another lib content",
	}
	tempDir := setupRemoveTestEnvironment(t, projectTomlContent, lockTomlContent, depFilesToCreate)

	err = os.Chdir(tempDir)
	require.NoError(t, err, "Failed to change to temporary directory")

	// Run the remove command for 'manifestonlylib'
	err = runRemoveCommand(t, tempDir, "manifestonlylib")
	require.NoError(t, err, "runRemoveCommand should not return a fatal error for manifest-only dependency")

	// Verify project.toml is updated (manifestonlylib removed, anotherlib remains)
	var projData struct {
		Dependencies map[string]project.Dependency `toml:"dependencies"`
	}
	projBytes, err := os.ReadFile(filepath.Join(tempDir, config.ProjectTomlName))
	require.NoError(t, err)
	err = toml.Unmarshal(projBytes, &projData)
	require.NoError(t, err)
	assert.NotContains(t, projData.Dependencies, "manifestonlylib", "manifestonlylib should be removed from project.toml")
	assert.Contains(t, projData.Dependencies, "anotherlib", "anotherlib should still exist in project.toml")

	// Verify almd-lock.toml is processed (manifestonlylib was not there, anotherlib remains)
	var lockData struct {
		Package map[string]lockfile.PackageEntry `toml:"package"`
	}
	lockBytes, err := os.ReadFile(filepath.Join(tempDir, lockfile.LockfileName))
	require.NoError(t, err)
	err = toml.Unmarshal(lockBytes, &lockData)
	require.NoError(t, err)
	assert.NotContains(t, lockData.Package, "manifestonlylib", "manifestonlylib should not be in almd-lock.toml")
	assert.Contains(t, lockData.Package, "anotherlib", "anotherlib should still exist in almd-lock.toml")

	// Verify the 'manifestonlylib.lua' file is deleted
	_, err = os.Stat(filepath.Join(tempDir, "libs", "manifestonlylib.lua"))
	assert.True(t, os.IsNotExist(err), "manifestonlylib.lua should be deleted")

	// Verify the 'anotherlib.lua' file still exists
	_, err = os.Stat(filepath.Join(tempDir, "libs", "anotherlib.lua"))
	assert.NoError(t, err, "anotherlib.lua should still exist")

	// Verify 'libs' directory for 'manifestonlylib.lua' was removed if it became empty
	// (In this case, 'libs' dir will still contain 'anotherlib.lua', so it won't be removed)
	// If 'anotherlib.lua' was also removed in a different test, then 'libs' would be gone.
	// Here, we just ensure 'manifestonlylib.lua' is gone.
}

func TestRemoveCommand_EmptyProjectToml(t *testing.T) {
	originalWd, err := os.Getwd()
	require.NoError(t, err, "Failed to get current working directory")
	defer func() {
		require.NoError(t, os.Chdir(originalWd), "Failed to restore original working directory")
	}()

	// Setup: Temp dir with empty project.toml and empty almd-lock.toml.
	tempDir := setupRemoveTestEnvironment(t, "", "", nil)

	err = os.Chdir(tempDir)
	require.NoError(t, err, "Failed to change to temporary directory")

	depNameToRemove := "any-dep"

	// Execute: almd remove <dependency_name>
	err = runRemoveCommand(t, tempDir, depNameToRemove)

	// Verify: Command returns an error indicating dependency not found
	require.Error(t, err, "Expected an error when project.toml is empty")

	exitErr, ok := err.(cli.ExitCoder)
	require.True(t, ok, "Error should be a cli.ExitCoder")
	assert.Equal(t, 1, exitErr.ExitCode(), "Expected exit code 1")
	// With the changes in remove.go, if project.toml is empty (or has no [dependencies] table),
	// it should return "Error: No dependencies found in project.toml."
	assert.Equal(t, "Error: No dependencies found in project.toml.", exitErr.Error())

	// Verify: files remain empty or unchanged.
	projectTomlPath := filepath.Join(tempDir, config.ProjectTomlName)
	projectTomlBytes, err := os.ReadFile(projectTomlPath)
	require.NoError(t, err, "Failed to read project.toml after command")
	assert.Equal(t, "", string(projectTomlBytes), "project.toml should remain empty")

	lockfilePath := filepath.Join(tempDir, lockfile.LockfileName)
	lockfileBytes, err := os.ReadFile(lockfilePath)
	require.NoError(t, err, "Failed to read almd-lock.toml after command")
	assert.Equal(t, "", string(lockfileBytes), "almd-lock.toml should remain empty")
}

// Helper Functions
func setupRemoveTestEnvironment(t *testing.T, initialProjectTomlContent string, initialLockfileContent string, depFiles map[string]string) (tempDir string) {
	t.Helper()
	tempDir = t.TempDir()

	// Always create project.toml, using provided content (empty string means empty file)
	projectTomlPath := filepath.Join(tempDir, config.ProjectTomlName)
	err := os.WriteFile(projectTomlPath, []byte(initialProjectTomlContent), 0644)
	require.NoError(t, err, "Failed to write project.toml")

	// Always create almd-lock.toml, using provided content (empty string means empty file)
	lockfilePath := filepath.Join(tempDir, lockfile.LockfileName)
	err = os.WriteFile(lockfilePath, []byte(initialLockfileContent), 0644)
	require.NoError(t, err, "Failed to write almd-lock.toml")

	for relPath, content := range depFiles {
		absPath := filepath.Join(tempDir, relPath)
		err := os.MkdirAll(filepath.Dir(absPath), 0755)
		require.NoError(t, err, "Failed to create directory for dependency file: %s", filepath.Dir(absPath))
		err = os.WriteFile(absPath, []byte(content), 0644)
		require.NoError(t, err, "Failed to write dependency file: %s", absPath)
	}

	return tempDir
}

func runRemoveCommand(t *testing.T, workDir string, removeCmdArgs ...string) error {
	t.Helper()

	// Remove working directory handling from here since it's now handled in the test
	app := &cli.App{
		Name: "almd-test-remove",
		Commands: []*cli.Command{
			RemoveCommand(),
		},
		Writer:         os.Stderr,
		ErrWriter:      os.Stderr,
		ExitErrHandler: func(context *cli.Context, err error) {},
	}

	cliArgs := []string{"almd-test-remove", "remove"}
	cliArgs = append(cliArgs, removeCmdArgs...)

	return app.Run(cliArgs)
}



================================================
File: internal/core/config/config.go
================================================
package config

import (
	"bytes"
	"os"
	"path/filepath"

	"github.com/BurntSushi/toml"
	"github.com/nightconcept/almandine-go/internal/core/project" // Corrected module path
)

const ProjectTomlName = "project.toml"
const LockfileName = "almd-lock.toml"

// LoadProjectToml reads the project.toml file from the given dirPath and unmarshals it.
func LoadProjectToml(dirPath string) (*project.Project, error) {
	fullPath := filepath.Join(dirPath, ProjectTomlName)
	data, err := os.ReadFile(fullPath)
	if err != nil {
		return nil, err
	}

	var proj project.Project
	if err := toml.Unmarshal(data, &proj); err != nil {
		return nil, err
	}
	return &proj, nil
}

// WriteProjectToml marshals the Project data and writes it to the specified dirPath.
// It will overwrite the file if it already exists.
func WriteProjectToml(dirPath string, data *project.Project) error {
	buf := new(bytes.Buffer)
	if err := toml.NewEncoder(buf).Encode(data); err != nil {
		return err
	}

	// Write the TOML content to the file, overwriting if it exists.
	// Create the file if it doesn't exist, with default permissions (0666 before umask).
	// O_TRUNC ensures that if the file exists, its content is truncated.
	fullPath := filepath.Join(dirPath, ProjectTomlName)
	file, err := os.OpenFile(fullPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer func() { _ = file.Close() }()

	_, err = file.Write(buf.Bytes())
	return err
}



================================================
File: internal/core/downloader/downloader.go
================================================
// Package downloader provides functionality to download files from URLs.
package downloader

import (
	"fmt"
	"io"
	"net/http"
)

// DownloadFile fetches the content from the given URL.
// It returns the content as a byte slice or an error if the download fails
// or if the HTTP status code is not 200 OK.
func DownloadFile(url string) ([]byte, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, fmt.Errorf("failed to perform GET request to %s: %w", url, err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to download from %s: received status code %d", url, resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body from %s: %w", url, err)
	}

	return body, nil
}



================================================
File: internal/core/hasher/hasher.go
================================================
package hasher

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
)

// CalculateSHA256 computes the SHA256 hash of the given content
// and returns it in the format "sha256:<hex_hash>".
func CalculateSHA256(content []byte) (string, error) {
	hasher := sha256.New()
	_, err := hasher.Write(content) // Capture potential error from Write, though rare for byte slices
	if err != nil {
		return "", fmt.Errorf("failed to write content to hasher: %w", err)
	}
	hashBytes := hasher.Sum(nil)
	hashString := hex.EncodeToString(hashBytes)
	return fmt.Sprintf("sha256:%s", hashString), nil
}



================================================
File: internal/core/lockfile/lockfile.go
================================================
package lockfile

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/BurntSushi/toml"
)

const LockfileName = "almd-lock.toml"
const APIVersion = "1"

// PackageEntry represents a single package entry in the lockfile.
// Example:
// [packages."dependency-name"]
//
//	source = "exact raw download URL"
//	path = "relative/path/to/file.ext"
//	hash = "sha256:<hash_value>" or "commit:<commit_hash>"
type PackageEntry struct {
	Source string `toml:"source"`
	Path   string `toml:"path"`
	Hash   string `toml:"hash"`
}

// Lockfile represents the structure of the almd-lock.toml file.
type Lockfile struct {
	ApiVersion string                  `toml:"api_version"`
	Package    map[string]PackageEntry `toml:"package"`
}

// New creates a new Lockfile instance with default values.
func New() *Lockfile {
	return &Lockfile{
		ApiVersion: APIVersion,
		Package:    make(map[string]PackageEntry),
	}
}

// Load loads the lockfile from the given project root path.
// If the lockfile doesn't exist, it returns a new Lockfile instance.
func Load(projectRoot string) (*Lockfile, error) {
	lockfilePath := filepath.Join(projectRoot, LockfileName)
	lf := New()

	if _, err := os.Stat(lockfilePath); os.IsNotExist(err) {
		return lf, nil // Return a new lockfile if it doesn't exist
	} else if err != nil {
		return nil, fmt.Errorf("failed to stat lockfile %s: %w", lockfilePath, err)
	}

	if _, err := toml.DecodeFile(lockfilePath, &lf); err != nil {
		return nil, fmt.Errorf("failed to decode lockfile %s: %w", lockfilePath, err)
	}
	// Ensure API version is present, even if file was empty or had it missing
	if lf.ApiVersion == "" {
		lf.ApiVersion = APIVersion
	}
	// Ensure Packages map is initialized
	if lf.Package == nil {
		lf.Package = make(map[string]PackageEntry)
	}
	return lf, nil
}

// Save saves the lockfile to the given project root path.
func Save(projectRoot string, lf *Lockfile) error {
	lockfilePath := filepath.Join(projectRoot, LockfileName)
	file, err := os.Create(lockfilePath)
	if err != nil {
		return fmt.Errorf("failed to create/truncate lockfile %s: %w", lockfilePath, err)
	}
	defer func() { _ = file.Close() }()

	encoder := toml.NewEncoder(file)
	if err := encoder.Encode(lf); err != nil {
		return fmt.Errorf("failed to encode lockfile %s: %w", lockfilePath, err)
	}
	return nil
}

// AddOrUpdatePackage adds or updates a package entry in the lockfile.
func (lf *Lockfile) AddOrUpdatePackage(name, rawURL, relativePath, integrityHash string) {
	if lf.Package == nil {
		lf.Package = make(map[string]PackageEntry)
	}
	lf.Package[name] = PackageEntry{
		Source: rawURL,
		Path:   relativePath,
		Hash:   integrityHash,
	}
}



================================================
File: internal/core/project/project.go
================================================
package project

// Project represents the overall structure of the project.toml file.
type Project struct {
	Package      *PackageInfo          `toml:"package"`
	Scripts      map[string]string     `toml:"scripts,omitempty"`
	Dependencies map[string]Dependency `toml:"dependencies,omitempty"`
}

// PackageInfo holds metadata for the project.
type PackageInfo struct {
	Name        string `toml:"name"`
	Version     string `toml:"version"`
	License     string `toml:"license,omitempty"`
	Description string `toml:"description,omitempty"`
}

// Dependency represents a single dependency in the project.toml file.
type Dependency struct {
	Source string `toml:"source"`
	Path   string `toml:"path"`
}

// LockFile represents the structure of the almd-lock.toml file.
type LockFile struct {
	APIVersion string                       `toml:"api_version"`
	Package    map[string]LockPackageDetail `toml:"package"`
}

// LockPackageDetail represents a single package entry in the almd-lock.toml file.
type LockPackageDetail struct {
	Source string `toml:"source"` // The exact raw download URL
	Path   string `toml:"path"`   // Relative path to the downloaded file
	Hash   string `toml:"hash"`   // Integrity hash (e.g., "sha256:<hash>" or "commit:<hash>")
}

// NewProject creates and returns a new Project instance with initialized maps.
func NewProject() *Project {
	return &Project{
		Package:      &PackageInfo{}, // Initialize PackageInfo as well
		Scripts:      make(map[string]string),
		Dependencies: make(map[string]Dependency),
	}
}



================================================
File: internal/core/source/github_api.go
================================================
package source

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"
)

// GithubAPIBaseURL allows overriding for tests. It is an exported variable.
var GithubAPIBaseURL = "https://api.github.com"

// GitHubCommitInfo minimal structure to parse the commit SHA.
type GitHubCommitInfo struct {
	SHA    string `json:"sha"`
	Commit struct {
		Committer struct {
			Date time.Time `json:"date"`
		} `json:"committer"`
	} `json:"commit"`
	// We only need the SHA, but including date for potential future use/sorting.
}

// GetLatestCommitSHAForFile fetches the latest commit SHA for a specific file on a given branch/ref from GitHub.
// owner: repository owner
// repo: repository name
// pathInRepo: path to the file within the repository
// ref: branch name, tag name, or commit SHA
func GetLatestCommitSHAForFile(owner, repo, pathInRepo, ref string) (string, error) {
	// Construct the API URL
	// See: https://docs.github.com/en/rest/commits/commits#list-commits
	// We ask for commits for a specific file on a specific branch/ref. The first result is the latest.
	apiURL := fmt.Sprintf("%s/repos/%s/%s/commits?path=%s&sha=%s&per_page=1", GithubAPIBaseURL, owner, repo, pathInRepo, ref)

	httpClient := &http.Client{Timeout: 10 * time.Second}
	req, err := http.NewRequest("GET", apiURL, nil)
	if err != nil {
		return "", fmt.Errorf("failed to create request to GitHub API: %w", err)
	}
	// GitHub API recommends setting an Accept header.
	req.Header.Set("Accept", "application/vnd.github.v3+json")
	// Consider adding a User-Agent header for more robust requests.
	// req.Header.Set("User-Agent", "almandine-go-cli")

	resp, err := httpClient.Do(req)
	if err != nil {
		return "", fmt.Errorf("failed to call GitHub API (%s): %w", apiURL, err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		bodyBytes, _ := io.ReadAll(resp.Body)
		return "", fmt.Errorf("GitHub API request failed with status %s (%s): %s", resp.Status, apiURL, string(bodyBytes))
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read response body from GitHub API (%s): %w", apiURL, err)
	}

	var commits []GitHubCommitInfo
	if err := json.Unmarshal(body, &commits); err != nil {
		return "", fmt.Errorf("failed to unmarshal GitHub API response (%s): %w. Body: %s", apiURL, err, string(body))
	}

	if len(commits) == 0 {
		// This can happen if the path is incorrect for the given ref, or the ref itself doesn't exist.
		// Or if the ref *is* a commit SHA, and the file wasn't modified in that specific commit (the API returns history).
		// If ref is already a SHA, we should ideally use it directly. This function assumes ref might be a branch.
		// If no commits are returned for a file on a branch, it implies the file might not exist on that branch or path is wrong.
		return "", fmt.Errorf("no commits found for path '%s' at ref '%s' in repo '%s/%s'. The file might not exist at this path/ref, or the ref might be a specific commit SHA where this file was not modified", pathInRepo, ref, owner, repo)
	}

	return commits[0].SHA, nil
}



================================================
File: internal/core/source/source.go
================================================
package source

import (
	"fmt"
	"net/url"
	"strings"
)

// testModeBypassHostValidation is an internal flag for testing to bypass hostname checks.
// WARNING: This should only be set to true in test environments.
var testModeBypassHostValidation = false

// SetTestModeBypassHostValidation enables or disables the hostname validation bypass for testing.
// This function is intended to be called only from test packages.
func SetTestModeBypassHostValidation(enable bool) {
	testModeBypassHostValidation = enable
}

// ParsedSourceInfo holds the details extracted from a source URL.
type ParsedSourceInfo struct {
	RawURL            string // The raw URL to download the file content
	CanonicalURL      string // The canonical representation (e.g., github:owner/repo/path/to/file@ref)
	Ref               string // The commit hash, branch, or tag
	Provider          string // e.g., "github"
	Owner             string
	Repo              string
	PathInRepo        string
	SuggestedFilename string
}

// ParseSourceURL analyzes the input source URL string and returns structured information.
// It currently prioritizes GitHub URLs.
func ParseSourceURL(sourceURL string) (*ParsedSourceInfo, error) {
	if strings.HasPrefix(sourceURL, "github:") {
		// Handle github:owner/repo/path/to/file@ref format
		content := strings.TrimPrefix(sourceURL, "github:")

		lastAt := strings.LastIndex(content, "@")
		if lastAt == -1 {
			return nil, fmt.Errorf("invalid github shorthand source '%s': missing @ref (e.g., @main or @commitsha)", sourceURL)
		}
		if lastAt == len(content)-1 {
			return nil, fmt.Errorf("invalid github shorthand source '%s': ref part is empty after @", sourceURL)
		}

		repoAndPathPart := content[:lastAt]
		ref := content[lastAt+1:]

		pathComponents := strings.Split(repoAndPathPart, "/")
		if len(pathComponents) < 3 {
			return nil, fmt.Errorf("invalid github shorthand source '%s': expected format owner/repo/path/to/file, got '%s'", sourceURL, repoAndPathPart)
		}

		owner := pathComponents[0]
		repo := pathComponents[1]
		pathInRepo := strings.Join(pathComponents[2:], "/")
		suggestedFilename := pathComponents[len(pathComponents)-1]

		if owner == "" || repo == "" || pathInRepo == "" || suggestedFilename == "" {
			return nil, fmt.Errorf("invalid github shorthand source '%s': owner, repo, or path/filename cannot be empty", sourceURL)
		}

		var rawURL string
		if testModeBypassHostValidation {
			// In test mode, construct the RawURL using the (potentially mocked) GithubAPIBaseURL
			// and the expected path structure for raw content.
			// GithubAPIBaseURL in tests is mockServer.URL (e.g., http://127.0.0.1:XYZ)
			// The path should be /<owner>/<repo>/<ref>/<path_to_file...>
			rawURL = fmt.Sprintf("%s/%s/%s/%s/%s", GithubAPIBaseURL, owner, repo, ref, pathInRepo)
		} else {
			rawURL = fmt.Sprintf("https://raw.githubusercontent.com/%s/%s/%s/%s", owner, repo, ref, pathInRepo)
		}

		return &ParsedSourceInfo{
			RawURL:            rawURL,
			CanonicalURL:      sourceURL, // The input is already the canonical form for this type
			Ref:               ref,
			Provider:          "github",
			Owner:             owner,
			Repo:              repo,
			PathInRepo:        pathInRepo,
			SuggestedFilename: suggestedFilename,
		}, nil
	}

	// Existing logic for full URLs
	u, err := url.Parse(sourceURL)
	if err != nil {
		return nil, fmt.Errorf("failed to parse source URL '%s': %w", sourceURL, err)
	}

	if testModeBypassHostValidation {
		// In test mode, directly construct ParsedSourceInfo assuming a GitHub-like raw content path structure.
		// Path structure expected: /<owner>/<repo>/<ref>/<path_to_file...>
		pathParts := strings.Split(strings.Trim(u.Path, "/"), "/")
		if len(pathParts) < 4 { // Expect at least owner, repo, ref, and one file part
			return nil, fmt.Errorf("test mode URL path '%s' not in expected format /<owner>/<repo>/<ref>/<file...> PpathParts was: %v", u.Path, pathParts)
		}

		owner := pathParts[0]
		repo := pathParts[1]
		ref := pathParts[2]
		filePathInRepo := strings.Join(pathParts[3:], "/")
		filename := pathParts[len(pathParts)-1]

		// Ensure filename is not empty if filePathInRepo was just "/"
		if filename == "" && filePathInRepo == "" {
			// This case implies path was like /owner/repo/ref/ which is not a file
			return nil, fmt.Errorf("test mode URL path '%s' seems to point to a directory, not a file", u.Path)
		}
		if filename == "" && len(pathParts) == 4 { // e.g. /owner/repo/ref/ (empty filename part)
			filename = pathParts[3] // take the last segment as filename if not further nested
		}

		return &ParsedSourceInfo{
			RawURL:            u.String(),                                                          // Use the mock server's actual URL for download
			CanonicalURL:      fmt.Sprintf("github:%s/%s/%s@%s", owner, repo, filePathInRepo, ref), // Construct a canonical URL
			Ref:               ref,
			Provider:          "github", // Simulate GitHub provider
			Owner:             owner,
			Repo:              repo,
			PathInRepo:        filePathInRepo,
			SuggestedFilename: filename,
		}, nil
	}

	if strings.ToLower(u.Hostname()) == "github.com" || strings.ToLower(u.Hostname()) == "raw.githubusercontent.com" {
		return parseGitHubURL(u)
	}

	// Placeholder for other providers or generic git repositories
	return nil, fmt.Errorf("unsupported source URL host: %s. Only GitHub URLs are currently supported", u.Hostname())
}

// parseGitHubURL handles the specifics of parsing GitHub URLs.
func parseGitHubURL(u *url.URL) (*ParsedSourceInfo, error) {
	// Path components: /<owner>/<repo>/<type>/<ref>/<path_to_file>
	// or /<owner>/<repo>/raw/<ref>/<path_to_file>
	// or /<owner>/<repo> (if wanting to point to a whole repo, though we expect a file)
	// Example: https://github.com/owner/repo/blob/main/path/to/file.go
	// Example: https://github.com/owner/repo/raw/develop/script.sh
	// Example: https://raw.githubusercontent.com/owner/repo/main/path/to/file.go

	pathParts := strings.Split(strings.Trim(u.Path, "/"), "/")
	if strings.ToLower(u.Hostname()) == "raw.githubusercontent.com" {
		// Format: /<owner>/<repo>/<ref>/<path_to_file>
		if len(pathParts) < 4 {
			return nil, fmt.Errorf("invalid GitHub raw content URL path: %s. Expected format: /<owner>/<repo>/<ref>/<path_to_file>", u.Path)
		}
		owner := pathParts[0]
		repo := pathParts[1]
		ref := pathParts[2]
		filePathInRepo := strings.Join(pathParts[3:], "/")
		filename := pathParts[len(pathParts)-1]

		canonicalURL := fmt.Sprintf("github:%s/%s/%s@%s", owner, repo, filePathInRepo, ref)
		// The input URL is already the raw download URL
		return &ParsedSourceInfo{
			RawURL:            u.String(),
			CanonicalURL:      canonicalURL,
			Ref:               ref,
			Provider:          "github",
			Owner:             owner,
			Repo:              repo,
			PathInRepo:        filePathInRepo,
			SuggestedFilename: filename,
		}, nil
	}

	// Regular github.com URL
	if len(pathParts) < 2 {
		return nil, fmt.Errorf("invalid GitHub URL path: %s. Expected at least /<owner>/<repo>", u.Path)
	}

	owner := pathParts[0]
	repo := pathParts[1]
	var ref, filePathInRepo, rawURL, filename string

	// /<owner>/<repo> - this case is not directly supported as we need a file.
	// We could default to fetching default branch's project file or error out.
	// For now, let's assume the URL is more specific.

	// Check for patterns like /blob/, /tree/, /raw/
	// /<owner>/<repo>/blob/<ref>/<path_to_file>
	// /<owner>/<repo>/raw/<ref>/<path_to_file> (less common for user input but possible)
	if len(pathParts) >= 4 && (pathParts[2] == "blob" || pathParts[2] == "tree" || pathParts[2] == "raw") {
		if len(pathParts) < 5 {
			return nil, fmt.Errorf("incomplete GitHub URL path: %s. Expected /<owner>/<repo>/<type>/<ref>/<path_to_file>", u.Path)
		}
		refType := pathParts[2] // blob, tree, or raw
		ref = pathParts[3]
		filePathInRepo = strings.Join(pathParts[4:], "/")
		filename = pathParts[len(pathParts)-1]

		if refType == "tree" {
			return nil, fmt.Errorf("direct links to GitHub trees are not supported for adding single files: %s", u.String())
		}
		// Normalize to raw content URL
		rawURL = fmt.Sprintf("https://raw.githubusercontent.com/%s/%s/%s/%s", owner, repo, ref, filePathInRepo)

	} else {
		// Try to extract ref and path if a shorthand URL is given, e.g., github.com/owner/repo/file.txt@main
		// This means the path might contain '@' for the ref.
		// If no type (blob/tree/raw) and path has more than 2 parts (/owner/repo/...)
		// we assume the structure is /owner/repo/path@ref or /owner/repo/path (implies default branch)
		// For Almandine, we will require the ref to be explicit in the path via @ or a more specific URL type.

		// The PRD implies a specific ref might be part of the source_url string itself,
		// rather than always inferred from structure.
		// "Extract commit hash/ref if present."

		// Let's use a regex to find ref in the path for URLs like:
		// github.com/user/repo/path/to/file.txt@v1.0.0
		// github.com/user/repo/path/to/file.txt@commitsha
		// github.com/user/repo/path/to/file.txt (implies default branch, but we need a way to get it)
		// For now, we'll assume if no /blob/ or /raw/ and no @ in path, we might need to query default branch.
		// Task 2.2 focuses on parsing, let's assume ref is extractable or default is handled later.

		// Simplified: if not blob/raw/tree, the path from part 2 onwards is file path, ref needs to be found or assumed.
		// For now, let's require a ref to be specified using '@' if not using blob/raw URLs.
		// Example: github.com/owner/repo/some/file.go@main

		potentialPathWithRef := strings.Join(pathParts[2:], "/")
		atSymbolIndex := strings.LastIndex(potentialPathWithRef, "@")

		if atSymbolIndex != -1 {
			filePathInRepo = potentialPathWithRef[:atSymbolIndex]
			ref = potentialPathWithRef[atSymbolIndex+1:]
			pathElements := strings.Split(filePathInRepo, "/")
			if len(pathElements) > 0 {
				filename = pathElements[len(pathElements)-1]
			} else {
				filename = "default_filename" // Or error if path is empty
			}
		} else {
			// No explicit ref in path, no blob/raw.
			// This case is ambiguous without fetching default branch info from GitHub API.
			// For now, we'll error or require a more specific URL.
			// Let's assume default ref = "main" for now, can be enhanced.
			// This part might need adjustment based on how we fetch default branch or if we enforce explicit refs always.
			// For simplicity in this step, let's error if ref is not obvious.
			return nil, fmt.Errorf("ambiguous GitHub URL: %s. Specify a branch/tag/commit via '@' (e.g., file.txt@main) or use a full /blob/ or /raw/ URL", u.String())
		}
		rawURL = fmt.Sprintf("https://raw.githubusercontent.com/%s/%s/%s/%s", owner, repo, ref, filePathInRepo)
	}

	if filePathInRepo == "" {
		return nil, fmt.Errorf("file path in repository could not be determined from URL: %s", u.String())
	}
	if ref == "" {
		// This should ideally fetch the default branch, but that's an external call.
		// For parsing, we'll state that ref couldn't be determined if not explicitly part of URL.
		return nil, fmt.Errorf("ref (branch, tag, commit) could not be determined from URL: %s. Please specify it", u.String())
	}

	canonicalURL := fmt.Sprintf("github:%s/%s/%s@%s", owner, repo, filePathInRepo, ref)

	return &ParsedSourceInfo{
		RawURL:            rawURL,
		CanonicalURL:      canonicalURL,
		Ref:               ref,
		Provider:          "github",
		Owner:             owner,
		Repo:              repo,
		PathInRepo:        filePathInRepo,
		SuggestedFilename: filename,
	}, nil
}



================================================
File: project/PRD.md
================================================
# Almandine Package Manager (Go Version) - PRD

## 1. Introduction

Almandine (`almd` as the CLI command) is a lightweight package manager for Go projects, migrating the core concepts from the original Lua version. It enables simple, direct management of single-file dependencies (initially from GitHub), project scripts, and project metadata. Almandine is designed for projects that want to pin specific versions or commits of files without managing complex dependency trees, leveraging Go's strengths and the `urfave/cli` framework.

## 2. Core Features

-   **Single-file Downloads:** Fetch individual files (initially Lua, but adaptable) from remote repositories (e.g., GitHub), pinning by git commit hash or potentially tags/versions later.
-   **No Dependency Tree Management:** Only downloads files explicitly listed in the project; does not resolve or manage full dependency trees.
-   **Project Metadata:** Maintains project name, type, version, license, and package description in `project.toml` (using TOML format).
-   **Script Runner:** Provides a central point for running project scripts defined in `project.toml`.
-   **Lockfile:** Tracks exact versions or commit hashes of all downloaded files for reproducible builds (`almd-lock.toml`, using TOML format).
-   **License & Description:** Exposes license and package description fields in `project.toml`.
-   **Cross-Platform:** Built as a standard Go binary, naturally cross-platform (Linux, macOS, Windows).

### 2.1. Core Commands (Initial Focus using `urfave/cli`)

-   **`init` command:**
    -   **Goal:** Interactively initialize a new Almandine project by creating a `project.toml` manifest file in the current directory.
    -   **Implementation:** Implemented as a `urfave/cli` command (in `internal/cli/initcmd/initcmd.go`).
    -   **Functionality:**
        -   **Interactive Prompts:** Prompts the user for core project metadata:
            -   `package` name (defaults to `my-go-project` or derived from current dir).
            -   `version` (defaults to `0.1.0`).
            -   `license` (defaults to `MIT`).
            -   `description` (defaults to `A sample Go project using Almandine.`).
            -   Optionally prompts for `language` details (e.g., name `go`, version `>= 1.21`).
        -   **Script Definition:** Interactively prompts the user to add scripts ([`scripts`] table).
            -   Prompts for script `name` and `command`.
            -   Continues prompting until an empty name is entered.
            -   **Default `run` script:** If no `run` script is provided by the user, adds a default (e.g., `go run ./cmd/almd` or a user-project specific default like `go run .`).
        -   **Dependency Placeholders (Simplified):** Interactively prompts the user to add initial dependencies ([`dependencies`] table).
            -   Prompts for dependency `name` and a simple `source/version` string.
            -   Continues prompting until an empty name is entered.
            -   **Note:** `init` creates basic dependency entries. The `add` command is responsible for fleshing these out into the full structure (`source` identifier, `path`).
        -   **Manifest Creation/Overwrite:** Creates `project.toml` in the current directory with the collected information. If `project.toml` already exists, it **overwrites** the existing file.
        -   **Output:** Prints confirmation message upon successful creation/overwrite. Reports errors clearly via `urfave/cli` if file writing fails.
    -   **Arguments & Flags (`urfave/cli`):**
        -   Typically run without arguments or flags, relying purely on interactive input.

-   **`add` command:**
    -   **Goal:** Adds a single-file dependency from a supported source (initially GitHub URLs) to the project.
    -   **Implementation:** Implemented as a `urfave/cli` command (defined in `internal/cli/add/add.go`).
    -   **Functionality:**
        -   Parses the provided URL using Go's `net/url`.
        -   **GitHub URL Processing:** Handles various GitHub URL formats (blob, raw, potentially commit/tag specific). Normalizes the input URL to the **raw content download URL**. Extracts the commit hash if present in the URL. Creates a **canonical source identifier** (e.g., `github:user/repo/path/to/file@commit_hash_or_ref`) for storage in `project.toml`. This logic is encapsulated in `internal/source`.
        -   Downloads the specified file using Go's `net/http` client from the resolved raw content URL (logic in `internal/downloader`).
        -   **Target Directory/Path Handling:** Determines the final destination path for the downloaded file based on the `-d` and `-n` flags. Ensures the target directory exists, creating it if necessary using `os.MkdirAll`.
        -   Saves the downloaded file to the determined target path using `os` and `io` packages.
        -   **Manifest Update (`project.toml`):** Updates the `project.toml` file (using a Go TOML library like `github.com/BurntSushi/toml` and logic in `internal/core/config`). Adds or modifies the dependency entry under the `[dependencies]` table. The key is the derived or specified dependency name (`-n` flag). The value **must be a sub-table** containing:
            -   `source`: The **canonical source identifier** derived from the input URL.
            -   `path`: The relative path (using forward slashes) from the project root to the downloaded file.
        -   **Lockfile Update (`almd-lock.toml`):** Updates the `almd-lock.toml` file (using a TOML library and logic in `internal/core/lockfile`). Adds or updates the entry for the dependency under the `[package]` table. This entry stores:
            -   `source`: The **exact raw download URL** used to fetch the file.
            -   `path`: The relative path (using forward slashes) matching the manifest.
            -   `hash`: A string representing the file's integrity. Format: `commit:<commit_hash>` if a commit was extracted from the URL, otherwise `sha256:<sha256_hash>` calculated from the downloaded content using `crypto/sha256` (logic in `internal/hasher`). Defines how hash calculation errors are represented (e.g., `hash_error:<reason>`).
        -   **Error Handling & Atomicity:** Implement robust error handling. If the process fails after download but before saving manifest/lockfile, attempts to clean up the downloaded file. Reports errors clearly via `urfave/cli` (e.g., using `cli.Exit`).
    -   **Arguments & Flags (`urfave/cli`):**
        -   `<source_url>`: Argument accessed from `*cli.Context` for the source URL of the file (required).
        -   `-d, --directory string`: Flag definition (`cli.StringFlag`) for specifying the target directory. If the path ends in a separator or points to an existing directory, the file is saved inside that directory using the name derived from the `-n` flag or the URL. Otherwise, the flag value is treated as the full relative path for the saved file. Defaults to saving within the `libs/` directory (or `src/lib/` if specified).
        -   `-n, --name string`: Flag definition (`cli.StringFlag`) for specifying the logical name of the dependency (used as the key in `project.toml` and `almd-lock.toml`) and the base filename. If omitted, the name is inferred from the URL's filename component.
        -   `--verbose`: Optional flag (`cli.BoolFlag`) to enable detailed output during execution.

-   **`remove` command:**
    -   **Goal:** Removes a specified dependency from the project manifest (`project.toml`) and lockfile (`almd-lock.toml`), and deletes the corresponding downloaded file.
    -   **Implementation:** Implemented as a `urfave/cli` command (e.g., `commands/remove.go`).
    -   **Functionality:**
        -   **Argument Parsing:** Takes the `<dependency_name>` as a required argument from `*cli.Context`.
        -   **Manifest Loading:** Loads the `project.toml` file (using `internal/config`).
        -   **Dependency Check:** Verifies if the specified `<dependency_name>` exists under the `[dependencies]` table in the manifest.
        -   **Path Retrieval:** Retrieves the relative `path` associated with the dependency from the manifest entry.
        -   **Manifest Update:** Removes the entry corresponding to `<dependency_name>` from the `[dependencies]` table.
        -   **Manifest Saving:** Saves the modified manifest back to `project.toml`.
        -   **File Deletion:** Deletes the file specified by the retrieved `path` using `os.Remove`. Handles potential errors gracefully (e.g., file not found, permissions).
        -   **Lockfile Update:** Loads the `almd-lock.toml` file (using `internal/lockfile`), removes the corresponding entry under the `[package]` table, and saves the updated lockfile.
        -   **Output:** Prints confirmation messages for successful removal from manifest, file deletion (or warnings if deletion fails), and lockfile update. Reports errors clearly via `urfave/cli`.
    -   **Arguments & Flags (`urfave/cli`):**
        -   `<dependency_name>`: Argument accessed from `*cli.Context` for the logical name of the dependency to remove (required).
-   **`install` command:**
    -   **Goal:** Installs or updates specified dependencies to the versions dictated by `project.toml`, or refreshes all dependencies if no specific ones are named. It ensures that the local project state (downloaded files and `almd-lock.toml`) aligns with the desired state specified in `project.toml`.
    -   **Implementation:** To be implemented as a `urfave/cli` command (e.g., in `internal/cli/install/install.go`).
    -   **Functionality:**
        -   **Argument Parsing:** Accepts an optional list of `<dependency_name>` arguments from `*cli.Context`. If no names are provided, it targets all dependencies listed in `project.toml`.
        -   **Manifest & Lockfile Loading:** Loads `project.toml` (using `internal/core/config`) and `almd-lock.toml` (using `internal/core/lockfile`).
        -   **Dependency Iteration:** For each targeted dependency:
            1.  **Retrieve Project Configuration:** Fetches the dependency's configuration (its canonical `source` identifier and `path`) from the `[dependencies]` table in `project.toml`. If a specified dependency name is not found in `project.toml`, it will be skipped with a warning.
            2.  **Resolve Target Version/Source:** The `source` string from `project.toml` (e.g., `github:user/repo/file.lua@main` or `github:user/repo/file.lua@v1.2.3`) defines the desired state. This source identifier is resolved to a concrete, downloadable raw URL and a definitive commit hash or version identifier (e.g., the latest commit hash on the `main` branch, or the commit hash corresponding to tag `v1.2.3`). This resolution logic resides in `internal/source`.
            3.  **Retrieve Current Lockfile State:** Fetches the current locked state for this dependency from `almd-lock.toml`, if an entry exists. This includes the exact raw `source` URL previously used for download and the integrity `hash` (e.g., `commit:<hash>` or `sha256:<hash>`).
            4.  **Comparison and Decision Logic:**
                -   An install/update is required if:
                    -   The resolved target commit hash (from step 2) differs from the commit hash recorded in `almd-lock.toml` (from step 3).
                    -   The dependency is present in `project.toml` but missing from `almd-lock.toml`.
                    -   The local file at the dependency's `path` is missing, even if hashes might otherwise match.
                    -   A `--force` flag is used by the user.
                -   If the resolved target commit hash matches the one in `almd-lock.toml` and the local file exists, the dependency is considered up-to-date with its `project.toml` specification, and no action is taken unless forced.
            5.  **Perform Install/Update (if required):**
                -   The file is downloaded from the resolved target raw URL (using `internal/downloader`).
                -   The integrity hash is calculated for the downloaded content (commit hash is preferred if available from the source URL, otherwise SHA256 via `internal/hasher`).
                -   The downloaded file is saved to its designated `path` (from `project.toml`), ensuring that any necessary parent directories are created.
                -   The `almd-lock.toml` file is updated: the entry for the dependency will store the exact raw download URL used, the `path`, and the new integrity `hash`.
                -   **Note on `project.toml`:** The `source` field in `project.toml` typically remains as specified by the user (e.g., it can continue to point to a branch like `main`). The `almd-lock.toml` file is always updated to store the pinned, concrete version details (specific commit hash and exact download URL).
        -   **Output:** Provides clear feedback, indicating which dependencies were checked, which were installed/updated, and which were already up-to-date. Errors encountered during the process are reported clearly via `urfave/cli`.
    -   **Arguments & Flags (`urfave/cli`):**
        -   `[dependency_names...]`: Optional argument(s) accessed from `*cli.Context` specifying the logical names of the dependencies to install/update. If omitted, all dependencies defined in `project.toml` are targeted.
        -   `--force`, `-f`: Optional flag (`cli.BoolFlag`) to compel re-downloading of files and updating of lockfile entries, even if the resolved version appears to be identical to the currently locked version.
        -   `--verbose`: Optional flag (`cli.BoolFlag`) to enable more detailed logging output during execution.

-   **`list` command (aliased as `ls`):**
    -   **Goal:** Displays a list of project dependencies, showing their configured sources from `project.toml`, their local paths, and their locked versions or hashes from `almd-lock.toml`.
    -   **Implementation:** To be implemented as a `urfave/cli` command (e.g., in `internal/cli/list/list.go`).
    -   **Functionality:**
        -   **Manifest & Lockfile Loading:** Loads `project.toml` (via `internal/core/config`) and `almd-lock.toml` (via `internal/core/lockfile`).
        -   **Dependency Traversal:** Iterates through the dependencies defined in the `[dependencies]` table of `project.toml`. For each dependency:
            -   Retrieves its logical name, the configured `source` identifier, and its relative `path` from `project.toml`.
            -   Attempts to retrieve its corresponding entry from `almd-lock.toml` to get the locked raw `source` URL and the integrity `hash`.
        -   **Output Formatting:** Displays information in a format similar to `pnpm list`. It will use the `fatih/color` library for terminal coloring, respecting the `NO_COLOR` environment variable.
            -   **Project Information Line:**
                -   Format: `ProjectName@Version /path/to/project/root`
                -   Colors:
                    -   Project Name: Magenta (`color.FgMagenta`)
                    -   `@`: Standard terminal color
                    -   Version: Magenta (`color.FgMagenta`)
                    -   Path: Dim Gray (`color.FgHiBlack`)
            -   An empty line follows the project information.
            -   **"dependencies:" Header:**
                -   Text: `dependencies:`
                -   Color: Cyan and Bold (`color.FgCyan`, `color.Bold`)
            -   **Dependency Lines:**
                -   Format: `DependencyName LockedHash RelativePath`
                -   Colors:
                    -   Dependency Name: White (`color.FgWhite`)
                    -   Locked Hash: Yellow (`color.FgYellow`) (e.g., `commit:<hash>` or `sha256:<hash>`, or "not locked" in standard color if applicable)
                    -   Relative Path: Dim Gray (`color.FgHiBlack`)
            -   If no dependencies, after the "dependencies:" header, "(none)" will be printed in standard color.
        -   **Extended Information (e.g., with a `--long` or `-l` flag):**
            -   The full locked raw `source` URL from `almd-lock.toml`.
            -   Status indication, e.g., "INSTALLED" (if local file at `path` exists and optionally matches hash), "MISSING" (if local file at `path` does not exist), "NOT_LOCKED".
            -   (Future/Advanced) Potentially indicate if a newer version is available if the `project.toml` source is a "floating" reference (like a branch name) and it resolves to a newer commit than what's in the lockfile. This would require resolving the `project.toml` source during the list operation.
        -   **No Dependencies:** If `project.toml` contains no dependencies, the "dependencies:" header is still printed, followed by "(none)".
    -   **Arguments & Flags (`urfave/cli`):**
        -   `--long`, `-l`: Optional flag (`cli.BoolFlag`) to display more detailed information for each listed dependency.
        -   `--json`: Optional flag (`cli.BoolFlag`) to output the dependency list in JSON format, suitable for machine parsing.
        -   `--porcelain`: Optional flag (`cli.BoolFlag`) for a simple, scriptable output format (e.g., `name@version_hash path`).


## 3. Almandine Tool Project Structure (Go Implementation)

Standard Go project layout combined with Almandine specifics:

-   `project.toml`       # Default project manifest filename for projects using Almandine
-   `almd-lock.toml`     # Default lockfile filename for projects using Almandine
-   `go.mod`               # Go module definition for Almandine tool
-   `go.sum`               # Go module checksums for Almandine tool
-   `README.md`            # Project README for Almandine development
-   `.github/`             # GitHub-specific files (workflows, issue templates, etc.)
-   `cmd/`                 # Main applications for the project
    -   `almd/`            # The Almandine CLI application (assuming CLI command is 'almd')
        -   `main.go`      # Main entry point, CLI argument parsing, command dispatch
-   `internal/`            # Private application and library code (not for external import)
    -   `cli/`             # CLI command logic and definitions
        -   `add/`         # Logic for the 'add' command
            -   `add.go`
            -   `add_test.go`
        -   `initcmd/`     # Logic for the 'init' command
            -   `initcmd.go`
            -   `initcmd_test.go`
        -   `remove/`      # Logic for the 'remove' command
            -   `remove.go`
        -   `...`          # Other command packages/modules
    -   `core/`            # Core application logic (business logic)
        -   `config/`      # Loading, parsing, and updating `project.toml`
            -   `config.go`
            -   `config_test.go`
        -   `lockfile/`    # Loading, parsing, and updating `almd-lock.toml`
            -   `lockfile.go`
            -   `lockfile_test.go`
        -   `downloader/`  # File downloading logic
            -   `downloader.go`
            -   `downloader_test.go`
        -   `hasher/`      # Content hashing logic (e.g., SHA256)
            -   `hasher.go`
            -   `hasher_test.go`
        -   `project/`     # Go structs representing project/lockfile data models
            -   `project.go`
        -   `source/`      # Handling source URL parsing, normalization, identifier creation
            -   `source.go`
            -   `source_test.go`
    -   `util/`            # General utility functions shared across internal packages
-   `pkg/`                 # Public library code, reusable by other projects (if any - initially empty)
    -   `...`              # Example: `pkg/somepublicapi/`
-   `scripts/`             # Scripts for building, installing, analyzing the Almandine tool itself (e.g., `build.sh`, `install.sh`)
-   `configs/`             # Configuration files for the Almandine tool (e.g., for different environments - placeholder)
-   `docs/`                # Almandine tool's own documentation (user guides, design documents, PRD, etc.)
-   `test/`                # Additional tests (e.g., E2E, integration) and test data
    -   `e2e/`             # End-to-end tests
    -   `data/`            # Test data, fixtures (optional)

The directory `lib/` (mentioned in the previous structure) is not part of the Almandine tool's own source code structure. It typically refers to the default output directory within a *user's project* where Almandine might download dependencies (e.g., `src/lib/` or a user-configured path).

Unit tests (e.g., `foo_test.go`) should be co-located with the Go source files they test (e.g., in the same package/directory like `internal/core/config/config_test.go`). The top-level `test/` directory is for tests that span multiple packages or require specific data/environments (e.g., end-to-end tests).

## 3.1 Example Lua Project Structure (Using Almandine)

This shows a typical layout for a Lua project managed by the Almandine tool:

-   `project.toml`       # Defines project metadata, scripts, and dependencies for Almandine
-   `almd-lock.toml`  # Stores locked dependency versions/hashes generated by Almandine

-   `src/`                 # Lua project source code
    -   `main.lua`         # Example entry point for the Lua project
    -   `my_module.lua`
    -   `lib/`                 # Default directory where Almandine downloads dependencies (user-configurable)
        -   `some_dependency.lua` # Example file downloaded by Almandine
        -   `another_lib/`        # Example library downloaded by Almandine
        -   `module.lua`
-   `scripts/`             # Optional directory for Lua scripts runnable via `almd run <script_name>`
    -   `build.lua`

## 4. File Descriptions

### `project.toml`

Project manifest in TOML format. Example structure based on user input:

```toml
# Example project.toml
package = "sample-project"
version = "0.1.0"
license = "MIT"
description = "A sample Go project using Almandine."
# language = { name = "go", version = ">=1.21" } # Example if language details are added

# Optional: Define primary source if needed for context
# [source]
# url = "https://github.com/nvim-neorocks/luarocks-stub" # Example purpose

# Dependencies section
[dependencies]
# Name inferred from URL (e.g., 'lua-cjson')
# [dependencies."lua-cjson"] # Name can be explicitly set with -n
#   source = "github:user/repo/lua-cjson.lua@tag-2.1.0" # Canonical identifier
#   path = "src/lib/lua-cjson.lua" # Relative path in project

# Dependency added with -n flag and custom path via -d
[dependencies."plenary"] # Specified via -n plenary
  source = "github:nvim-lua/plenary.nvim/some/file.lua@v0.1.4"
  path = "src/vendor/plenary.lua" # Specified via -d src/vendor/plenary.lua
  # Could potentially add other metadata like 'pin = true' if needed later

# Optional: Build or script definitions
[build]
type = "builtin" # Example build type

# Example scripts section (similar to npm scripts)
[scripts]
game = "love src/"
debug = "love src/ --console"
test = "love src/ --console --test"

```
-   Handles project metadata (name, version, etc.).
-   Defines dependencies under `[dependencies]`. Each dependency is a key (the logical name) mapping to a **sub-table** containing `source` (canonical identifier) and `path` (relative location).
-   Defines project scripts under `[scripts]`.

### `almd-lock.toml`

Tracks resolved dependencies for reproducible installs in TOML format. Example structure:

```toml
# Example almd-lock.toml
# Lockfile format version (increment if structure changes significantly)
api_version = "1"

# Package table holds all locked dependencies
[package]

# Entry for a dependency 'mylib', locked from project.toml entry
[package.mylib]
  # The *exact* raw download URL used to fetch this version
  source = "https://raw.githubusercontent.com/user/repo/v1.0.0/path/to/file.ext"
  # Relative path within the project (forward slashes)
  path = "vendor/custom/mylib" # Example, matches project.toml path
  # Integrity hash: commit hash if available from source URL, otherwise sha256 of content
  hash = "sha256:deadbeef..." # Example sha256 hash
  # Example of a commit hash from URL:
  # hash = "commit:abcdef123..."

# Entry for 'anotherdep', locked from project.toml entry
[package."anotherdep"]
  source = "https://raw.githubusercontent.com/another/repo/main/lib.lua"
  path = "libs/lib.lua" # Example, default path
  hash = "commit:abcdef123" # Example if pinned to a specific commit hash
  # Example of a hash error state:
  # hash = "hash_error:tool_not_found" # Or "hash_error:calculation_failed"

```
-   Stores the exact resolved `source` (raw download URL), `path`, and `hash` (content or commit or error state) for each dependency under the `[package]` table.
-   The `api_version` helps manage potential future format changes.

### `go.mod` & `go.sum`

Standard Go module files defining the project module path and managing Go dependencies.

### `main.go`

Main entry point for the `almd` CLI. This file initializes and configures the primary `cli.App` instance from the `urfave/cli` library. It defines global application metadata (like name, usage, version), global flags, registers all command definitions (e.g., from the `commands/` package or defined directly), and then executes the application logic by calling `app.Run(os.Args)`, which parses arguments and routes execution to the appropriate command's `Action` function.

commands/ (Go Project Command Packages)

Contains Go packages, each implementing a specific CLI command (e.g., add, init, remove). The add package would contain the Go logic for the add command.
cmd/almd/main.go (Go Project Entrypoint)

    Main entry point for the almd CLI executable.
    Responsible for:
        Parsing CLI arguments using a Go library (e.g., standard flag, cobra, urfave/cli).
        Dispatching execution to the appropriate command package in cmd/almd/commands/.
        Handling standard command aliases (e.g., install/in/ins, remove/rm/uninstall/un, update/up/upgrade, add/i, etc.) within the CLI library configuration.
        All usage/help output, documentation, and examples must use almd as the CLI tool name (never almandine).
        Updates here are required when adding/modifying commands or aliases.

Build & Distribution (Go Context)

    The install/ directory (containing Lua bootstrap scripts) is removed.
    Distribution involves building the Go project (go build ./cmd/almd) to produce a native executable (almd or almd.exe) for each target platform (Linux, macOS, Windows).
    Standard Go cross-compilation techniques will be used. Users simply download and place the appropriate binary in their PATH.

5. Conclusion

Almandine, implemented in Go, aims to provide a simple, robust, and reproducible workflow for Lua projects needing lightweight dependency management and script automation, without the complexity of full dependency trees. It leverages Go's strengths for building reliable, cross-platform CLI tools while managing Lua project structures and manifests.
Tech Stack

    Implementation Language: Go (e.g., 1.21 or later)
    Target Project Language: Lua 5.1√¢‚Ç¨‚Äú5.4 / LuaJIT 2.1 (though Almandine itself is Go, it can manage files for any language)
    Platform (Tool): Cross-platform executable (Linux, macOS, Windows) via Go compilation.
    Key Go Libraries (Potential):
        Standard Library: net/http, os, os/exec, path/filepath, crypto/sha256, flag or similar for CLI.
        External Go Modules:
            A TOML parser/generator library (e.g., `github.com/BurntSushi/toml`).
            A robust CLI framework (e.g., `github.com/urfave/cli/v2`).
            An assertion library for testing (e.g., `github.com/stretchr/testify/assert`).
            A terminal color library (e.g., `github.com/fatih/color`) for enhanced CLI output.
            Possibly a Git client library (e.g., go-git/go-git) if direct Git operations are needed beyond simple HTTP downloads (not currently planned for initial features).

## 5. Project-Specific Coding Rules (Go Implementation)

These rules supplement the mandatory Global AI Project Guidelines and define standards specific to this Go project.
### 5.1 Language, Environment & Dependencies

    Target Language: Go (specify version, e.g., Go 1.21+).
    Environment: Standard Go development environment.
    Dependencies:
        Leverage the Go Standard Library extensively.
        External Go modules should be carefully chosen and documented in go.mod. Justify non-standard library dependencies. Key required external dependency: a library for parsing/generating Lua table syntax accurately.
        The compiled almd tool must have no runtime dependencies (like needing a specific interpreter installed).

### 5.2 Go Coding Standards

These standards guide Go development within this project.

    Formatting: All Go code must be formatted using gofmt (or goimports). This is non-negotiable and should be enforced by CI.
    Style: Adhere to the principles outlined in Effective Go and the Go Code Review Comments guide.
        Naming: Use CamelCase for exported identifiers and camelCase for unexported identifiers. Package names should be short, concise, and lowercase.
        Simplicity: Prefer clear, simple code over overly complex or clever solutions.
    Error Handling: Use standard Go error handling practices (if err != nil { return ..., err }). Errors should be handled or propagated explicitly. Use errors.Is, errors.As, and error wrapping (fmt.Errorf("...: %w", err)) where appropriate.
    Concurrency: Use goroutines and channels only when concurrency genuinely simplifies the problem or improves performance, and do so carefully, considering race conditions and synchronization.
    Packages: Structure code into logical, well-defined packages with clear APIs. Minimize unnecessary coupling between packages. Utilize internal packages (internal/) for code not meant to be imported by other modules.
    Documentation:
        All exported identifiers (variables, constants, functions, types, methods) must have documentation comments (// style comments preceding the declaration).
        Package comments (// package mypackage ...) should provide an overview of the package's purpose.
        Comments should explain why something is done, not just what is being done, unless the code itself is unclear. Follow godoc conventions.

### 5.3 Testing & Behavior Specification (Prototype Phase - Go Context)

These rules specify how testing and behavior specification are implemented using Go's standard testing package during the prototype phase.

    Framework: Use Go's built-in `testing` package. Test assertions use `github.com/stretchr/testify/assert`.
    Specification Location:
        Unit/Integration tests: Place test files (`*_test.go`) alongside the Go code they are testing (e.g., `internal/core/config/config_test.go` tests `internal/core/config/config.go`). Command-specific unit tests (e.g., for `init`, `add`) are located in their respective packages (e.g., `internal/cli/add/add_test.go`).
        E2E Tests (Prototype Focus): Place E2E tests in a dedicated location, such as `cmd/almd/main_e2e_test.go` or a top-level `test/e2e/` directory. For the prototype, command-specific tests that execute the CLI (like those in `internal/cli/add/add_test.go` which run an `app.Run` instance) serve as focused E2E-like tests for command behavior.
    File Naming: Test files must end with `_test.go`. Test functions must start with `Test` (e.g., `TestAddCommand_HappyPath`).
    Test Type Focus (Prototype):
        Command Unit Tests: Test individual command actions (e.g., the `Action` func of an `urfave/cli.Command`). These tests mock external dependencies like network calls (`net/http/httptest`) and operate on a temporary file system.
        E2E Tests: Verify system behavior by executing the compiled `almd` binary (or a test `cli.App` instance) against temporary project structures. Simulate user interactions via CLI arguments.
    Test Sandboxing & Scaffolding: Tests must run in isolated, temporary directories.
        Use `t.TempDir()` (available in Go 1.15+) within test functions to create sandboxed directories.
        Develop Go helper functions (e.g., within test files or a shared test utility package) to:
            Set up temporary project structures (creating directories, minimal `project.toml`).
            Run the `almd` command or its action, capturing output and errors. For `add` command tests, this includes setting up mock HTTP servers (`net/http/httptest`).
            Provide functions for asserting file existence, file content (using `os.ReadFile`), and parsing/asserting the content of the resulting `project.toml` and `almd-lock.toml` files within the sandbox.
            Cleanup is handled automatically by `t.TempDir()` or explicit `defer os.RemoveAll()`.
    Scenario Coverage: Each test function or suite (`t.Run`) should cover specific scenarios:
        Expected Behavior: Successful flows (e.g., `almd add ...` works correctly, `almd init` creates files as expected).
        Boundary Conditions: Edge cases (e.g., adding the same file twice, invalid URLs, empty inputs for `init`).
        Undesired Situations: Error handling (e.g., non-existent URLs, file system permission errors, invalid `project.toml` format). Use helper functions to assert expected error messages or exit codes.
    Test Dependencies:
        Command unit tests mock external dependencies (network, file system interactions beyond the temp dir).
        E2E-style tests will naturally depend on the internal Go packages used for parsing/validation (e.g., `internal/core/config`, `internal/core/lockfile`).


================================================
File: project/TASKS.md
================================================
# Task Checklist: Almandine Go Implementation - `init` & `add` Commands

**Purpose:** Tracks tasks and milestones for implementing the core `init` and `add` commands for the Almandine Go CLI (`almd`), based on the specifications in `project/PRD.md`.

**Multiplatform Policy:** All implementations MUST be compatible with Linux, macOS, and Windows.

---

## Milestone 0: Initial Setup & `main.go` Entrypoint

**Goal:** Create the basic Go project structure and the main CLI entry point using `urfave/cli`.

-   [x] **Task 0.1: Initialize Go Module**
    -   [x] Run `go mod init <module_path>` (e.g., `go mod init github.com/your-user/almandine-go`). *User needs to determine the module path.*
    -   [x] Add `urfave/cli/v2` dependency (`go get github.com/urfave/cli/v2`).
    -   [x] Manual Verification: `go.mod` and `go.sum` are created/updated.

-   [x] **Task 0.2: Create `main.go`**
    -   [x] Create the `main.go` file at the project root.
    -   [x] Add the basic `main` function.
    -   [x] Manual Verification: File exists.

-   [x] **Task 0.3: Basic `urfave/cli` App Setup**
    -   [x] Import `urfave/cli/v2`.
    -   [x] Create a new `cli.App` instance in `main`.
    -   [x] Set the `Name` (`almd`), `Usage`, and `Version` for the app.
    -   [x] Implement the `app.Run(os.Args)` call.
    -   [x] Manual Verification: Run `go run main.go --version` and confirm the version is printed. Run `go run main.go --help` and confirm basic usage is shown.

-   [x] **Task 0.4: Define CLI Binary Name Convention**
    -   [x] Ensure the target executable name built by Go is `almd`.
    -   [x] *Note:* A separate wrapper script/alias named `almd` will be used by end-users to call `almd`. This task is about the Go build output name. (Build command might be `go build -o almd .`)
    -   [x] Manual Verification: Build the project (`go build -o almd .`) and confirm the output file is named `almd`.

---

## CLI Tool Name

-   The CLI executable is called `almd`.
-   All documentation, usage, and examples should refer to the CLI as `almd`.

---

## Milestone 1: `init` Command Implementation

**Goal:** Implement the `almd init` command to interactively create a `project.toml` manifest file.

-   [x] **Task 1.1: `urfave/cli` Command Setup**
    -   [x] Define the `init` command structure (`cli.Command`) within `commands/init.go`.
    -   [x] Add the command to the `urfave/cli` App in `main.go`.
    -   [x] Ensure basic command registration works (`almd init --help`).
    -   [x] Manual Verification: Run `almd init --help` and confirm the command is listed.

-   [x] **Task 1.2: Implement Interactive Prompts for Metadata**
    -   [x] Add logic within the `init` command's `Action` to prompt the user for:
        -   `package` name (with default).
        -   `version` (with default `0.1.0`).
        -   `license` (with default `MIT`).
        -   `description` (with default).
        -   Optional: `language` details (consider defaulting initially).
    -   [x] Manual Verification: Run `almd init` interactively and confirm prompts appear and capture input correctly.

-   [x] **Task 1.3: Implement Interactive Prompts for Scripts**
    -   [x] Add logic to loop, prompting for script `name` and `command`.
    -   [x] Store collected scripts (e.g., in a `map[string]string`).
    -   [x] Exit the loop when an empty script name is entered.
    -   [x] Implement logic to add a default `run` script (`lua src/main.lua`) if the user doesn't define one.
    -   [x] Manual Verification: Run `almd init` interactively, add a few scripts, skip adding `run`, and verify the default is included conceptually (actual file writing is next).

-   [x] **Task 1.4: Implement Interactive Prompts for Dependencies (Placeholders)**
    -   [x] Add logic to loop, prompting for dependency `name` and a simple `source/version` string (as per PRD).
    -   [x] Store collected dependency placeholders (e.g., in a `map[string]string` or `map[string]interface{}`).
    -   [x] Exit the loop when an empty dependency name is entered.
    -   [x] Manual Verification: Run `almd init` interactively, add a few placeholder dependencies.

-   [x] **Task 1.5: Implement `project.toml` Structure and Writing**
    -   [x] Define Go structs in `internal/project/` to represent the `project.toml` structure (package info, scripts, dependencies).
    -   [x] Create functions in `internal/config/` to marshal the collected data into the Go struct and write it to `project.toml` using a TOML library (`github.com/BurntSushi/toml`).
    -   [x] Ensure the function correctly handles overwriting an existing `project.toml`.
    -   [x] Integrate this writing logic into the `init` command's `Action`.
    -   [x] Add clear output messages (success, errors).
    -   [x] Manual Verification: Run `almd init`, provide input, and verify `project.toml` is created correctly with the specified data and defaults. Run again and verify it overwrites. Check error handling for write failures (e.g., permissions).

## Milestone 2: `add` Command Implementation

**Goal:** Implement the `almd add <source_url>` command to download a single-file dependency, update `project.toml`, and update `almd-lock.toml`.

-   [x] **Task 2.1: `urfave/cli` Command Setup & Argument/Flag Parsing**
    -   [x] Define the `add` command structure (`cli.Command`) in `commands/add.go`.
    -   [x] Define the required `<source_url>` argument.
    -   [x] Define the flags: `-d, --directory string`, `-n, --name string`, `--verbose bool`.
    -   [x] Add the command to the `urfave/cli` App in `main.go`.
    -   [x] Implement basic parsing logic within the `Action` to retrieve the argument and flag values.
    -   [x] Manual Verification: Run `almd add --help` and confirm the command, argument, and flags are listed correctly. Run `almd add some-url -n test -d testdir --verbose` and verify the values are accessible within the (currently empty) action.

-   [x] **Task 2.2: Implement Source URL Handling (`internal/source`)**
    -   [x] Create package `internal/source`.
    -   [x] Implement functions to parse the input `<source_url>` (`net/url`).
    -   [x] Implement logic specifically for GitHub URLs:
        -   Normalize various formats (blob, raw) to the raw content download URL.
        -   Extract commit hash/ref if present.
        -   Create the canonical source identifier string (e.g., `github:user/repo/path@hash`).
    -   [x] Define return structures or values for the raw URL, canonical identifier, and extracted commit hash.
    -   [x] Manual Verification: Test the parsing functions with various valid and invalid GitHub URL formats. (Code review of parsing logic done, specific unit tests are outside this immediate task but recommended next)

-   [x] **Task 2.3: Implement File Downloading (`internal/downloader`)**
    -   [x] Create package `internal/downloader`.
    -   [x] Implement a function that takes a URL (the raw download URL from Task 2.2) and fetches the content using `net/http`.
    -   [x] Handle potential HTTP errors (status codes, network issues).
    -   [x] Return the downloaded content (e.g., as `[]byte`).
    -   [x] Manual Verification: Test the download function with a known raw GitHub file URL. (Code implemented; manual test by user pending integration)

-   [x] **Task 2.4: Implement Target Path Logic & File Saving**
    -   [x] Add logic within the `add` command's `Action` to determine the final destination path based on the `-d` flag, `-n` flag (or inferred name), and the project root.
    -   [x] Use `os.MkdirAll` to create the target directory if it doesn't exist.
    -   [x] Use `os.WriteFile` to save the downloaded content (`[]byte` from Task 2.3) to the determined path.
    -   [x] Handle file writing errors.
    -   [x] Manual Verification: Run `almd add <url>` with different `-d` and `-n` combinations and verify the file is saved to the correct location with the correct name. Test directory creation.

-   [x] **Task 2.5: Implement Hashing (`internal/hasher`)**
    -   [x] Create package `internal/hasher`.
    -   [x] Implement a function to calculate the SHA256 hash of file content (`[]byte`) using `crypto/sha256`.
    -   [x] Format the output hash string as `sha256:<hex_hash>`.
    -   [x] Manual Verification: Test the hashing function with known content and verify the output hash.

-   [x] **Task 2.6: Define Data Structures (`internal/project`)**
    -   [x] Extend Go structs in `internal/project/` to represent the `dependencies` table structure in `project.toml` (sub-table with `source`, `path`).
    -   [x] Define Go structs for the `almd-lock.toml` structure (`api_version`, `[package]` table with entries containing `source`, `path`, `hash`).
    -   [x] Manual Verification: Code review confirms structs accurately model the TOML structures defined in `PRD.md`.

-   [x] **Task 2.7: Implement Manifest Update (`internal/config`)**
    -   [x] Add functions in `internal/config/` to:
        -   [x] Load an existing `project.toml`.
        -   [x] Add or update a dependency entry in the `[dependencies]` map using the dependency name (from `-n` or inferred), canonical source identifier (Task 2.2), and relative file path (Task 2.4).
        -   [x] Save the updated manifest back to `project.toml`.
    -   [x] Integrate this logic into the `add` command's `Action`.
    -   [x] Manual Verification: Run `almd add <url>`, then inspect `project.toml` to verify the dependency entry is added/updated correctly.

-   [x] **Task 2.8: Implement Lockfile Update (`internal/lockfile`)**
    -   [x] Create package `internal/lockfile`.
    -   [x] Add functions to:
        -   [x] Load `almd-lock.toml` (handling file not found initially).
        -   [x] Calculate the integrity hash string: `commit:<commit_hash>` (if available from Task 2.2) or `sha256:<hash>` (from Task 2.5). Handle potential hashing errors (`hash_error:<reason>`).
        -   [x] Add or update an entry in the `[package]` map using the dependency name, the *exact raw download URL* (Task 2.2), the relative file path (Task 2.4), and the calculated hash string.
        -   [x] Set/ensure `api_version = "1"`.
        -   [x] Save the updated lockfile back to `almd-lock.toml`.
    -   [x] Integrate this logic into the `add` command's `Action`.
    -   [x] Manual Verification: Run `almd add <url>`, then inspect `almd-lock.toml` to verify the entry is added/updated with the correct source URL, path, and hash format.

-   [x] **Task 2.9: Error Handling and Cleanup**
    -   [x] Review the `add` command's `Action` logic.
    -   [x] Implement error handling using `urfave/cli`'s error reporting (e.g., `cli.Exit`).
    -   [x] If an error occurs *after* downloading the file but *before* successfully updating both manifest and lockfile, attempt to delete the downloaded file to maintain consistency.
    -   [x] Ensure clear error messages are provided to the user.
    -   [x] Manual Verification: Test error scenarios: invalid URL, download failure, write permission errors for manifest/lockfile, simulate failures mid-process to check cleanup.

## Milestone 3: Initial Testing Setup

**Goal:** Establish the basic structure for tests for the `init` and `add` commands.

-   [x] **Task 3.1: Define Testing Strategy**
    -   [x] Framework: Standard Go `testing` package with `testify` for assertions.
    -   [x] `init` command: Unit tests directly invoking the command's `Action`, simulating user input (as in `commands/init_test.go`).
    -   [x] `add` command: Unit tests directly invoking the command's `Action` (via `app.Run` within the test).
        -   [x] Network calls for `add` will be mocked using `net/http/httptest`.
        -   [x] File system operations will occur in temporary directories created by tests.
    -   [x] Setup/Teardown: Tests will create temporary directories and necessary initial files (e.g., `project.toml`), and these will be cleaned up automatically by `t.TempDir()` or explicit `defer os.RemoveAll`.
    -   [x] Manual Verification: Review the chosen strategy for feasibility.

-   [x] **Task 3.2: Create Test File Structure**
    -   [x] Test file for `init` command: `commands/init_test.go` (exists).
    -   [x] Create test file for `add` command: `commands/add_test.go`.
    -   [x] Implement shared test helpers if applicable (e.g., for creating temp env, running command actions).
    -   [x] Manual Verification: Run `go test ./...` and confirm test files are picked up.

-   [ ] **Task 3.3: Implement `init` Command Test Cases (Existing)**
    -   [x] Basic `init` test case (as in `commands/init_test.go`).
    -   [x] `init` test case with defaults and empty inputs (as in `commands/init_test.go`).
    -   [x] **Sub-Task 3.3.1: Fix `TestInitCommand` failure "project.toml\project.toml: The system cannot find the path specified." (2025-05-08)**
        -   [x] Changed `config.WriteProjectToml("project.toml", ...)` to `config.WriteProjectToml(".", ...)` in `internal/cli/initcmd/initcmd.go` to correctly specify the current directory for `project.toml` creation.

-   [ ] **Task 3.4: Implement `add` Command Unit Test Cases**
    -   [x] **Sub-Task 3.4.1: Setup for `add` tests in `commands/add_test.go`**
        -   [x] Define `TestMain` if any global setup/teardown for `add` tests is needed.
        -   [x] Create helper: `setupAddTestEnvironment(t *testing.T, initialProjectTomlContent string) (tempDir string)` that creates a temp dir and a `project.toml`.
        -   [x] Create helper: `runAddCommand(t *testing.T, tempDir string, mockServerURL string, cliArgs ...string) error` to set up and run the `add` command's action using an `cli.App` instance.
        -   [x] Create helper: `startMockHTTPServer(t *testing.T, content string, expectedPath string, statusCode int) *httptest.Server`.
    -   [x] **Sub-Task 3.4.2: Test `almd add` - Successful Download and Update (Explicit Name, Custom Directory)**
        -   [x] Setup: Temp dir, basic `project.toml`, mock HTTP server serving test content.
        -   [x] Execute: `almd add <mock_url_to_file> -n mylib -d vendor/custom`.
        -   [x] Verify:
            -   `vendor/custom/mylib` created with correct content.
            -   `project.toml` updated with `[dependencies.mylib]` pointing to `source` and `path="vendor/custom/mylib"`.
            -   `almd-lock.toml` created/updated with `[package.mylib]` including `source`, `path`, and `hash="sha256:..."`.
    -   [x] **Sub-Task 3.4.3: Test `almd add` - Successful Download (Inferred Name, Default Directory)**
        -   [x] Execute: `almd add <mock_url_to_file.lua>`.
        -   [x] Verify:
            -   `libs/file.lua` (or project root, per PRD) created.
            -   Manifest and lockfile updated with inferred name `file.sh`.
    -   [x] **Sub-Task 3.4.4: Test `almd add` - GitHub URL with Commit Hash**
        -   [x] URL can include a commit hash segment (e.g., `file.lua@commitsha`) or a branch/tag name (e.g., `file.lua@main`).
        -   [x] Verify `almd-lock.toml` `hash` field reflects `commit:<actual_commit_sha>`. If original URL was a branch/tag, it's resolved to the latest commit SHA for that file on that branch/tag. If original URL was a commit SHA, that SHA is used.
        -   [x] If GitHub API call fails to resolve a branch/tag, or if not a GitHub URL, verify fallback to `sha256:<content_hash>`.
    -   [x] **Sub-Task 3.4.5: Test `almd add` - Error: Download Failure (HTTP Error)**
        -   [x] Mock server returns non-200 status.
        -   [x] Verify command returns an error.
        -   [x] Verify no dependency file is created.
        -   [x] Verify `project.toml` and `almd-lock.toml` are not modified (or created if they didn't exist).
    -   [x] **Sub-Task 3.4.6: Test `almd add` - Error: `project.toml` Not Found**
        -   [x] Run `add` in a temp dir without `project.toml`.
        -   [x] Verify command returns an appropriate error.
    -   [x] **Sub-Task 3.4.7: Test `almd add` - Cleanup on Failure (e.g., Lockfile Write Error)**
        -   [x] Difficult to precisely mock file system write errors without more DI.
        -   [x] Focus on: If download happens, but a subsequent step like TOML marshaling or lockfile writing fails, does the downloaded file get removed? (This might require a test where the mock HTTP server succeeds, but we introduce an error in a subsequent, controllable step if possible, or inspect code paths for this cleanup logic). Initially, can be a lower priority if hard to test cleanly.
    -   [x] **Sub-Task 3.4.8: Fix `TestAddCommand_ProjectTomlNotFound` (2025-05-07)**
        -   [x] Modified error message in `internal/cli/add/add.go` to include "no such file or directory" when `project.toml` is not found.
        -   [x] Refactored `Action` in `internal/cli/add/add.go` to use a named return error, ensuring the deferred cleanup logic correctly removes downloaded files when `project.toml` is missing and an error is returned.
        -   [x] Corrected variable types for `proj` (to `*project.Project`) and `lf` (to `*lockfile.Lockfile`) in `internal/cli/add/add.go` to resolve compiler errors.


## Milestone 4: `remove` Command Implementation

**Goal:** Implement the `almd remove <dependency_name>` command to remove a dependency from the project.

-   [x] **Task 4.1: `urfave/cli` Command Setup**
    -   [x] Define the `remove` command structure (`cli.Command`) in `commands/remove.go` (or `internal/cli/remove/remove.go` as per PRD folder structure).
    -   [x] Add the command to the `urfave/cli` App in `main.go`.
    -   [x] Define the required `<dependency_name>` argument.
    -   [x] Manual Verification: Run `almd remove --help` and confirm the command and argument are listed correctly. Run `almd remove some-dep` and verify the argument value is accessible within the (currently empty) action.

-   [x] **Task 4.2: Implement Manifest Loading and Dependency Path Retrieval**
    -   [x] Add logic within the `remove` command's `Action` to load `project.toml` (using `internal/config`).
    -   [x] Verify if the specified `<dependency_name>` exists in the `[dependencies]` table.
    -   [x] If it exists, retrieve the relative `path` of the dependency.
    -   [x] Handle errors if `project.toml` is not found or the dependency does not exist.
    -   [x] Manual Verification: Test with an existing `project.toml`. Try removing an existing and a non-existing dependency. Check error messages.

-   [x] **Task 4.3: Implement Manifest Update and File Deletion**
    -   [x] Remove the entry for `<dependency_name>` from the `[dependencies]` table in the loaded manifest data.
    -   [x] Save the updated manifest back to `project.toml`.
    -   [x] Delete the file specified by the retrieved `path` using `os.Remove`.
    -   [x] Handle potential errors during file saving and deletion (e.g., permissions, file not found for deletion).
    -   [x] Manual Verification: Add a dependency using `almd add`. Then use `almd remove <dep_name>`. Verify `project.toml` is updated and the file is deleted. Test error conditions like read-only `project.toml` or non-existent dependency file.

-   [x] **Task 4.4: Implement Lockfile Update**
    -   [x] Load `almd-lock.toml` (using `internal/lockfile`).
    -   [x] Remove the entry for `<dependency_name>` from the `[package]` table in the loaded lockfile data.
    -   [x] Save the updated lockfile back to `almd-lock.toml`.
    -   [x] Handle errors if `almd-lock.toml` is not found or during saving. Handle cases where the dependency might not be in the lockfile even if it was in the manifest.
    -   [x] Manual Verification: After successfully running `almd add`, run `almd remove <dep_name>`. Verify `almd-lock.toml` is updated. Test with missing or read-only `almd-lock.toml`.

-   [x] **Task 4.5: Error Handling and Output**
    -   [x] Ensure robust error handling for all operations using `urfave/cli`'s error reporting (e.g., `cli.Exit`).
    -   [x] Provide clear confirmation messages for successful removal (manifest, file, lockfile).
    -   [x] Provide clear error messages for different failure scenarios.
    -   [x] Manual Verification: Test various error paths (missing files, non-existent dependency, permission issues) and check for clear, user-friendly output.

-   [x] **Task 4.6: Implement Empty Directory Cleanup**
    -   [x] After successful file deletion in `remove` (Task 4.3), check if the parent directory of the deleted file is empty.
    -   [x] If the directory is empty, delete it.
    -   [x] Repeat this process, moving upwards to parent directories, deleting them if they become empty.
    -   [x] Stop if a directory is not empty, an error occurs, or a predefined boundary (e.g., project root, `libs/`, `vendor/`) is reached.
    -   [x] Ensure directory emptiness check is robust to prevent accidental deletion of non-empty directories.
    -   [x] Manual Verification: Test scenarios where single and multiple empty parent directories are cleaned up. Test scenarios where cleanup stops appropriately. (Note: Manual verification by user is pending actual use, code implements the logic).

## Milestone 5: `remove` Command Testing

**Goal:** Implement unit tests for the `remove` command.

-   [x] **Task 5.1: Create Test File Structure for `remove`**
    -   [x] Create test file: `internal/cli/remove/remove_test.go`.
    -   [x] Implement shared test helpers if applicable (e.g., for creating temp env with `project.toml`, `almd-lock.toml`, and dummy dependency files).

-   [ ] **Task 5.2: Implement `remove` Command Unit Test Cases**
    -   [x] **Sub-Task 5.2.1: Setup for `remove` tests**
        -   [x] Define `TestMain` if any global setup/teardown for `remove` tests is needed. (Skipped for now, can be added if specific global setup is identified)
        -   [x] Create helper: `setupRemoveTestEnvironment(t *testing.T, initialProjectTomlContent string, initialLockfileContent string, depFiles map[string]string) (tempDir string)` that creates a temp dir, `project.toml`, `almd-lock.toml`, and specified dependency files.
        -   [x] Create helper: `runRemoveCommand(t *testing.T, tempDir string, cliArgs ...string) error` to set up and run the `remove` command's action.
    -   [x] **Sub-Task 5.2.2: Test `almd remove` - Successful Removal**
        -   [x] Setup: Temp dir with `project.toml`, `almd-lock.toml`, and a dummy dependency file, all correctly linked.
        -   [x] Execute: `almd remove <dependency_name>`.
        -   [x] Verify:
            -   Dependency entry removed from `project.toml`.
            -   Dependency entry removed from `almd-lock.toml`.
            -   Dependency file deleted from the filesystem.
            -   Command returns no error.
    -   [x] **Sub-Task 5.2.3: Test `almd remove` - Error: Dependency Not Found in Manifest**
        -   [x] Setup: Temp dir with `project.toml` that does not contain the target dependency.
        -   [x] Execute: `almd remove <non_existent_dependency_name>`.
        -   [x] Verify:
            -   Command returns an appropriate error.
            -   `project.toml` and `almd-lock.toml` remain unchanged.
            -   No file deletion attempted for the non-existent dependency.
           -   [x] **Sub-Task 5.2.4: Test `almd remove` - Error: Dependency File Not Found for Deletion**
            -   [x] Setup: Temp dir with `project.toml` and `almd-lock.toml` listing a dependency, but the actual dependency file is missing.
            -   [x] Execute: `almd remove <dependency_name>`.
        -   [x] Verify:
        	-   Dependency entry removed from `project.toml`.
        	-   Dependency entry removed from `almd-lock.toml`.
        	-   Command may return a warning or error about file deletion failure, but manifest/lockfile changes should persist.
        	-   PRD: "Handles potential errors gracefully (e.g., file not found, permissions)."
       -   [x] **Sub-Task 5.2.5: Test `almd remove` - Error: `project.toml` Not Found (2025-05-08 - Refined fix for CWD handling)**
        -   [x] Setup: Run `remove` in a temp dir without `project.toml`.
        -   [x] Execute: `almd remove <dependency_name>`.
        -   [x] Verify: Command returns an appropriate error.
    -   [x] **Sub-Task 5.2.6: Test `almd remove` - Dependency in Manifest but not Lockfile**
        -   [x] Setup: Temp dir with `project.toml` listing a dependency, `almd-lock.toml` exists but doesn't list it, and the dependency file exists.
        -   [x] Execute: `almd remove <dependency_name>`.
        -   [x] Verify:
            -   Dependency entry removed from `project.toml`.
            -   `almd-lock.toml` is processed (attempt to remove, no error if not found).
            -   Dependency file deleted.
            -   Command completes successfully or with a notice about the lockfile state.
    -   [x] **Sub-Task 5.2.7: Test `almd remove` - Empty `project.toml` or `almd-lock.toml` (2025-05-08 - Empty project.toml case fixed)**
        -   [x] Setup: Temp dir with empty `project.toml` and/or `almd-lock.toml`.
        -   [x] Execute: `almd remove <dependency_name>`.
        -   [x] Verify: Command returns an error indicating dependency not found (for empty `project.toml`) or handles empty lockfile gracefully, and files remain empty or unchanged.

## Milestone 6: `install` Command Implementation

**Goal:** Implement the `almd install` command to refresh dependencies based on `project.toml` and update `almd-lock.toml`.

-   [x] **Task 6.1: `urfave/cli` Command Setup for `install`**
    -   [x] Define the `install` command structure (`cli.Command`) in `internal/cli/install/install.go`.
    -   [x] Add the command to the `urfave/cli` App in `main.go`.
    -   [x] Define optional `[dependency_names...]` argument.
    -   [x] Define flags: `--force, -f` (bool), `--verbose` (bool).
    -   [x] Manual Verification: Run `almd install --help` and confirm the command, argument, and flags are listed correctly.

-   [x] **Task 6.2: Argument Parsing and Initial Loading**
    -   [x] In the `install` command's `Action`, parse optional dependency names. If none, target all.
    -   [x] Load `project.toml` (using `internal/core/config`). Handle errors if not found.
    -   [x] Load `almd-lock.toml` (using `internal/core/lockfile`). Handle if not found (treat as all dependencies needing install/addition to lockfile).
    -   [x] Manual Verification: Test with and without dependency names. Check behavior with missing manifest/lockfile.

-   [x] **Task 6.3: Dependency Iteration and Configuration Retrieval**
    -   [x] Iterate through targeted dependencies (all from `project.toml` or specified names).
    -   [x] For each dependency:
        -   [x] Retrieve its configuration (canonical `source` identifier, `path`) from `project.toml`.
        -   [x] If a specified dependency name is not found in `project.toml`, skip with a warning.
    -   [x] Manual Verification: Code review logic for iteration and config fetching. Test with a mix of valid and invalid specified dependency names.

-   [x] **Task 6.4: Target Version Resolution and Lockfile State Retrieval**
    -   [x] For each dependency:
        -   [x] Resolve its `source` from `project.toml` to a concrete downloadable raw URL and a definitive commit hash/version identifier (using `internal/source`). This involves fetching latest commit for branches/tags if necessary.
        -   [x] Retrieve its current locked state (raw `source` URL, `hash`) from `almd-lock.toml`, if an entry exists.
        -   [x] **Sub-Task 6.4.1: Support `github:owner/repo/path/to/file@ref` shorthand in `internal/source` (2025-05-08)**
            -   [x] Modified `internal/core/source/source.go`'s `ParseSourceURL` function to correctly parse the shorthand, extract components, and build the raw download URL.
    -   [x] Manual Verification: Test source resolution for branches, tags, and specific commits. Check retrieval from lockfile. Test new shorthand format.

-   [x] **Task 6.5: Comparison Logic and Update Decision**
    -   [x] For each dependency, determine if an install is required based on PRD logic:
        -   [x] Resolved target commit hash (from `project.toml` source) differs from locked commit hash.
        -   [x] Dependency in `project.toml` but missing from `almd-lock.toml`.
        -   [x] Local file at `path` is missing.
        -   [x] `--force` flag is used.
    -   [x] If none of the above, the dependency is considered up-to-date.
    -   [x] Manual Verification: Code review decision logic against PRD.

-   [x] **Task 6.6: Perform Install (If Required)**
    -   [x] For each dependency needing an install:
        -   [x] Download the file from the resolved target raw URL (using `internal/downloader`).
        -   [x] Calculate integrity hash (commit hash preferred, else SHA256 via `internal/hasher`).
        -   [x] Save the downloaded file to its `path` (from `project.toml`), creating parent directories if needed.
        -   [x] Update `almd-lock.toml`: store the exact raw download URL used, `path`, and new integrity `hash`. The `source` in `project.toml` remains (e.g., can still be a branch).
    -   [x] Manual Verification: Test a scenario where an update is performed. Check downloaded file content, path, and `almd-lock.toml` changes.

-   [x] **Task 6.7: Output and Error Handling**
    -   [x] Provide clear feedback: which dependencies checked, updated, already up-to-date.
    -   [x] Report errors clearly (e.g., download failure, source resolution failure, file write failure) via `urfave/cli`.
    -   [x] Manual Verification: Observe output for various scenarios (updates, no updates, errors).

-   [x] **Task 6.8: Fix Lint Errors in `install.go` (2025-05-08)**
    -   [x] Corrected `lf.Packages` to `lf.Package` in `internal/cli/install/install.go`.
    -   [x] Corrected type `project.LockPackageDetail` to `lockfile.PackageEntry` for lockfile map values in `internal/cli/install/install.go`.

## Milestone 7: `install` Command Testing

**Goal:** Implement unit tests for the `install` command.

-   [x] **Task 7.1: Test File Structure and Helpers for `install` (2025-05-08)**
    -   [x] Create test file: `internal/cli/install/install_test.go`.
    -   [x] Develop test helpers:
        -   [x] `setupInstallTestEnvironment(...)`: Creates temp dir, `project.toml`, `almd-lock.toml`, mock dependency files.
        -   [x] `runInstallCommand(...)`: Executes the `install` command's action with specified args and context.
        -   [x] Mock HTTP server setup (similar to `add` command tests) for controlling download responses and simulating remote changes.

-   [ ] **Task 7.2: Implement `install` Command Unit Test Cases**
    -   [x] **Sub-Task 7.2.1: Test `almd install` - All dependencies, one needs install (commit hash change) (2025-05-08)**
        -   [x] Setup: `project.toml` specifies `depA@main`. `almd-lock.toml` has `depA` at `commit1`. Mock server resolves `main` for `depA` to `commit2` and serves new content.
        -   [x] Execute: `almd install`.
        -   [x] Verify: `depA` file updated, `almd-lock.toml` updated for `depA` to `commit2`. Other up-to-date deps untouched.
    -   [x] **Sub-Task 7.2.2: Test `almd install <dep_name>` - Specific dependency install**
        -   [x] Setup: Similar to 7.2.1, but also `depB` needs update.
        -   [x] Execute: `almd install depA`.
        -   [x] Verify: Only `depA` is updated. `depB` remains as per old lockfile.
    -   [x] **Sub-Task 7.2.3: Test `almd install` - All dependencies up-to-date**
        -   [x] Setup: `project.toml` sources resolve to same commits as in `almd-lock.toml`. Local files exist.
        -   [x] Execute: `almd install`.
        -   [x] Verify: No files downloaded, no changes to `almd-lock.toml`. Appropriate "up-to-date" messages.
    -   [x] **Sub-Task 7.2.4: Test `almd install` - Dependency in `project.toml` but missing from `almd-lock.toml` (2025-05-08)**
    -   [x] Setup: `depNew` in `project.toml`, but no entry in `almd-lock.toml`.
    -   [x] Execute: `almd install`.
    -   [x] Verify: `depNew` is downloaded, file saved, and entry added to `almd-lock.toml`.
    -   [x] **Sub-Task 7.2.5: Test `almd install` - Local dependency file missing (2025-05-08)**
    -   [x] Setup: `depA` in `project.toml` and `almd-lock.toml`, but its local file is deleted.
    -   [x] Execute: `almd install depA`.
    -   [x] Verify: `depA` is re-downloaded based on `almd-lock.toml`'s pinned version (or `project.toml` if it dictates a newer one). `almd-lock.toml` reflects the version downloaded.
    -   [x] **Sub-Task 7.2.6: Test `almd install --force` - Force install on an up-to-date dependency (2025-05-08)**
        -   [x] Setup: `depA` is up-to-date.
        -   [x] Execute: `almd install --force depA`.
        -   [x] Verify: `depA` is re-downloaded and `almd-lock.toml` entry is refreshed, even if commit hash was the same.
    -   [x] **Sub-Task 7.2.7: Test `almd install <non_existent_dep>` - Non-existent dependency specified (2025-05-08)**
        -   [x] Setup: `project.toml` does not contain `non_existent_dep`.
        -   [x] Execute: `almd install non_existent_dep`.
        -   [x] Verify: Warning message printed, no other actions taken for this dep. Other valid deps (if `install` was called without args but one was invalid) should process normally.
    -   [x] **Sub-Task 7.2.8: Test `almd install` - Error during download (2025-05-08)**
        -   [x] Setup: Mock server returns HTTP error for a dependency that needs update.
        -   [x] Execute: `almd install`.
        -   [x] Verify: Command reports error for that dependency. `almd-lock.toml` and local file for that dep remain unchanged or reflect pre-update state.
    -   [x] **Sub-Task 7.2.9: Test `almd install` - Error during source resolution (e.g., branch not found) (2025-05-08)**
        -   [x] Setup: `project.toml` points to `depA@nonexistent_branch`. Mock `internal/source` to simulate resolution failure.
        -   [x] Execute: `almd install depA`.
        -   [x] Verify: Command reports error for `depA`. No download attempt.
    -   [x] **Sub-Task 7.2.10: Test `almd install` - `project.toml` not found (2025-05-08)**
        -   [x] Setup: Run `install` in a temp dir without `project.toml`.
        -   [x] Execute: `almd install`.
        -   [x] Verify: Command returns an appropriate error.

## Milestone 8: `list` Command Implementation

**Goal:** Implement the `almd list` (and `ls`) command to display project dependencies.

-   [x] **Task 8.1: `urfave/cli` Command Setup for `list` (2025-05-08)**
    -   [x] Define the `list` command structure (`cli.Command`) in `internal/cli/list/list.go`.
    -   [x] Add `ls` as an alias for the `list` command.
    -   [x] Add the command to the `urfave/cli` App in `main.go`.
    -   [x] Manual Verification: Run `almd list --help` and `almd ls --help`. Confirm command, alias, and flags are listed.

-   [x] **Task 8.2: Manifest and Lockfile Loading for `list` (2025-05-08)**
    -   [x] In the `list` command's `Action`, load `project.toml` (using `internal/core/config`). Handle if not found (print "No dependencies..." or error).
    -   [x] Load `almd-lock.toml` (using `internal/core/lockfile`). Handle if not found (dependencies will show as "not locked").
    -   [x] Manual Verification: Test with missing manifest/lockfile.

-   [x] **Task 8.3: Dependency Traversal and Information Gathering (2025-05-08)**
    -   [x] Iterate through dependencies in `project.toml`'s `[dependencies]` table.
    -   [x] For each dependency, retrieve:
        -   [x] Logical name.
        -   [x] Configured `source` from `project.toml`.
        -   [x] Relative `path` from `project.toml`.
        -   [x] Locked raw `source` URL and `hash` from `almd-lock.toml` (if present).
        -   [x] Local file existence status at `path`.
    -   [x] Manual Verification: Code review data gathering logic.

-   [x] **Task 8.4: Default Output Formatting (2025-05-08)**
    -   [x] Implement the default output format as per PRD:
        -   [x] Logical dependency name.
        -   [x] Declared `source` from `project.toml`.
        -   [x] Locked `hash` from `almd-lock.toml` (or "not locked").
        -   [x] Relative `path`.
    -   [x] Manual Verification: Run `almd list` with a sample project and check output.

-   [x] **Task 8.5: Handling Projects with No Dependencies (2025-05-08)**
    -   [x] If `project.toml` has no `[dependencies]` table or it's empty, print an appropriate message (e.g., "No dependencies found in project.toml."). This should work for all output formats (default, long, json, porcelain - e.g. empty array for json).
    -   [x] Manual Verification: Test with an empty `project.toml` or one without dependencies.

## Milestone 9: `list` Command Testing

**Goal:** Implement unit tests for the `list` command.

-   [x] **Task 9.1: Test File Structure and Helpers for `list` (2025-05-08)**
    -   [x] Create test file: `internal/cli/list/list_test.go`.
    -   [x] Develop test helpers:
        -   [x] `setupListTestEnvironment(...)`: Creates temp dir, `project.toml`, `almd-lock.toml`, and optionally dummy dependency files.
        -   [x] `runListCommand(...)`: Executes the `list` command's action, capturing its stdout.

-   [ ] **Task 9.2: Implement `list` Command Unit Test Cases**
    -   [x] **Sub-Task 9.2.1: Test `almd list` - No dependencies (2025-05-08)**
        -   [x] Setup: Empty `project.toml` or no `[dependencies]` table.
        -   [x] Execute: `almd list`.
        -   [x] Verify: Output indicates no dependencies. For `--json`, verify empty array or appropriate null structure. (Note: JSON output not yet implemented, test verifies default behavior)
    -   [ ] **Sub-Task 9.2.2: Test `almd list` - Single dependency (fully installed and locked)**
        -   [ ] Setup: `project.toml` with one dep, `almd-lock.toml` with corresponding entry, local file exists.
        -   [ ] Execute: `almd list`.
        -   [ ] Verify: Correct default output for the dependency.
    -   [ ] **Sub-Task 9.2.3: Test `almd list` - Multiple dependencies with varied states**
        -   [ ] Setup: Mix of deps: one fully installed, one in manifest but not lockfile, one in manifest & lockfile but file missing.
        -   [ ] Execute: `almd list`.
        -   [ ] Verify: Correct default output for each, reflecting their state.
    -   [ ] **Sub-Task 9.2.4: Test `almd ls` (alias) - Verify alias works**
        -   [ ] Setup: Basic project with one dependency.
        -   [ ] Execute: `almd ls`.
        -   [ ] Verify: Output is identical to `almd list`.
    -   [ ] **Sub-Task 9.2.5: Test `almd list` - `project.toml` not found**
        -   [ ] Setup: Run `list` in a temp dir without `project.toml`.
        -   [ ] Execute: `almd list`.
        -   [ ] Verify: Command returns an appropriate error or "no dependencies" message as per PRD.

## Milestone 10: `list` Command Output Enhancement

**Goal:** Update the `almd list` command output to be more informative and visually similar to `pnpm list`, including terminal colors using `fatih/color`.

-   [x] **Task 10.1: Define `list` Output Structure and Color Scheme**
    -   [x] Define pnpm-like output structure: Project info, "dependencies:" header, then `name path hash` for each. (Covered by previous Task 10.2, updated 2025-05-08)
    -   [x] Specify color scheme using `fatih/color` (inspired by user-provided image):
        -   Project Name: Magenta, Bold, Underline (`color.FgMagenta`, `color.Bold`, `color.Underline`)
        -   `@`: Standard color
        -   Project Version: Magenta (`color.FgMagenta`) (Note: User did not specify bold/underline for version, keeping as is)
        -   Project Path: Dim Gray, Bold, Underline (`color.FgHiBlack`, `color.Bold`, `color.Underline`)
        -   `dependencies:` header: Cyan and Bold (`color.FgCyan`, `color.Bold`)
        -   Dependency Name: Yellow (`color.FgYellow`)
        -   Dependency Hash: Standard color (No specific color attribute, or `color.Reset`)
        -   Dependency Path: Green (`color.FgGreen`)
    -   [x] Ensure `NO_COLOR` environment variable is respected (typically handled by `fatih/color` automatically, but verify).

-   [x] **Task 10.2: Implement Output Changes in `internal/cli/list/list.go` (Initial pnpm-like format)**
    -   [x] Load project name and version.
    -   [x] Modify print statements to match the new pnpm-like format (without colors yet).

-   [x] **Task 10.3: Implement Color Output in `internal/cli/list/list.go`**
    -   [x] Add `github.com/fatih/color` as a project dependency.
    -   [x] Import `fatih/color` in `internal/cli/list/list.go`.
    -   [x] Update print statements to use the defined color scheme via `fatih/color` functions.

-   [ ] **Task 10.4: Update `list` Command Tests (Blocked by Task 9.1, 9.2)**
    -   [ ] Adjust existing tests in `internal/cli/list/list_test.go` to expect the new pnpm-like format (initially without asserting exact color codes, as this can be brittle). (File to be created in Task 9.1)
    -   [x] Consider adding a simple manual verification step for color output. (Decision: Manual verification will be needed)
    -   [ ] Add new test cases if necessary to cover different scenarios with the new format (e.g., project with name/version, project without). (To be done in Task 9.2)



================================================
File: .github/copilot-instructions.md
================================================
# AI Project Guidelines (Condensed)

**Objective:** Define mandatory process, coding, testing, and interaction standards for AI assistance.

## 1. Preparation

* **Project Context (Session Start):** ALWAYS review key project docs: `project/PRD.md` (architecture, goals, tech stack, versions, structure, style guide), `project/digest.txt` (current state summary), `project/TASKS.md` (assignments).
* **Task Prep (Before Work):**
    * ALWAYS consult `project/TASKS.md` for your assignment. If missing, add it (concise description, `YYYY-MM-DD`).
    * ALWAYS review relevant existing code *before* suggesting changes.

## 2. Implementation Planning

**Present this plan before providing code for a task:**

* Problem description (brief).
* Solution overview (high-level).
* Implementation steps (list).
* Risks/Challenges (foreseen).

## 3. Development Workflow

* **Plan First:** Present plan (Sec 2) before coding.
* **Focus:** Target the specific task from `TASKS.md`. No unrelated refactoring unless tasked.
* **Modification Approach:**
    * Prioritize minimal, incremental, clean, elegant, idiomatic changes.
    * Explain significant suggestions (Sec 5.4).
    * Propose beneficial low-risk refactoring.
    * Avoid duplication; use helpers/modules.
    * Explain use of language strengths/pitfalls if relevant.
* **Dependencies:** No new/updated external dependencies without explicit maintainer approval (check `project/PRD.md` for approved stack/versions). Use only approved dependencies.
* **Commits (User Task):** Follow Conventional Commits (`https://www.conventionalcommits.org/en/v1.0.0/`).
* **Manual Testing:** Provide clear user instructions for manually testing the task's changes.

## 4. Folder Structure

* **Strict Adherence:** Follow structure defined in `project/PRD.md`.
* **Changes:** No adding/removing/relocating files/dirs without prior maintainer approval. Approved structure changes require updating `project/PRD.md` *before* implementation.
* **Source Location:** All source code must be in `src/`.
* **Precedence:** This rule is foundational.

## 5. Coding Standards

### 5.1. General & Robustness

* Follow language best practices unless overridden by `project/PRD.md` or these guidelines.
* Prioritize: Clarity, maintainability, efficiency.
* Consider performance & basic security.
* Implement robust error handling (language norms or `PRD.md` spec); handle errors gracefully.

### 5.2. Modularity & Structure

* Keep files focused (ideally < 500 lines); refactor large ones.
* Prefer small, single-purpose functions.
* Structure code logically (per `project/PRD.md`) into modules.
* Use clear, consistent imports (relative for local packages). Verify paths.

### 5.3. Style & Formatting

* **Priority:** 1) `project/PRD.md`, 2) These rules, 3) Language common practices.
* **Type Hinting:** Mandatory for functions/classes/modules (dynamic languages).
* **Indentation:** 2 spaces.
* **Function Calls:** No space: `func()` not `func ()`.
* **Line Structure:** Avoid collapsing statements if clarity suffers.
* **Scope:** Default local. More descriptive names for wider scope. Avoid single-letter vars (except iterators/tiny scope; `i` only for loops). Use `_` for ignored vars.
* **Casing:** Match current file style; else language common style. `UPPER_CASE` for constants only.
* **Booleans:** Prefer `is_` prefix for boolean functions.
* **File Headers:** Top comment: Title (descriptive, not filename) + brief purpose. No version/OS info.

### 5.4. Documentation & Comments

* **Docstrings:** Required for public functions, classes, modules (standard format).
* **Code Comments:** Explain non-obvious logic, complex algorithms, decisions (*why*, not *what*).
* **Reasoning Comments:** Use `# Reason:` for complex block rationale.
* **README Updates:** Update `project/README.md` for core features, dependency changes, or setup/build modifications.

## 6. Testing

* **Goal:** Tests are living documentation specifying behavior. Use common language framework.
* **Behavior Specification:** Tests specify behavior. Type/scope/timing (e.g., E2E, Unit, Integration) defined in `project/PRD.md` per project phase.
* **Location:** Place tests in `/src/test` (Lua: `/src/spec`), mirroring `src/` structure (Sec 4).
    * Ex: Tests for `src/engine/mod.js` -> `src/test/engine/mod_test.js`.
    * Ex: Lua spec for `src/engine/mod.lua` -> `src/spec/engine/mod_spec.lua`.
* **Content:** Tests clearly describe expected behavior per `PRD.md` goals for the current phase.
    * **Prototype Phase:** Primary focus on automated E2E tests validating core functionality.
* **Strategy & Coverage:** Defined in `PRD.md`, evolves with phases.
    * **Prototype Phase:** E2E priority. Comprehensive unit tests & code coverage metrics (e.g., 100% statement coverage) are **not** the focus *unless* specified in `project/PRD.md` for a later phase demanding them.
* **Updating Tests:** Review/update tests with code changes to reflect *current* expected behavior. Fix failing/outdated tests promptly.

## 7. AI Interaction Protocols

### 7.1. Engineering Role & Audience

* **Role:** Act as a **Senior Software Engineer**.
* **Audience:** Target **Mid-Level Software Engineers** (code = best practices, clear, documented; explanations thorough; justify complex choices).

### 7.2. Interaction Guidelines

* Ask clarifying questions if needed; do not assume.
* Verify facts (libs, APIs, file paths); do not invent. Use MCP servers if available.
* Do not delete/overwrite code unless instructed or part of the defined task.
* Report significant blockers/errors *during* implementation promptly with context and suggestions.
* If a task seems complex, state potential benefit from a more advanced model **boldly** at the start (e.g., "**Suggestion: This complex refactoring might benefit from a more advanced model.**").
* Be friendly, helpful, collaborative.
* Explicitly state when task requirements are met. Mark task complete in `project/TASKS.md`.


================================================
File: .github/dependabot.yml
================================================
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      # Check for updates to GitHub Actions every week
      interval: "weekly"


================================================
File: .github/workflows/ci.yml
================================================
# CI workflow for lint, test, and coverage reporting (Coveralls)
# Runs on all pushes and PRs

name: Go CI

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  test:
    name: Test on Go ${{ matrix.go-version }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: [ '1.23', '1.24' ]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}

      - name: Install Go tools
        run: |
          go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
          go install github.com/mattn/goveralls@latest

      - name: Download Go modules
        run: go mod download

      - name: Lint source
        run: golangci-lint run ./...

      - name: Run tests with coverage
        run: go test -v ./... -race -coverprofile=coverage.out -covermode=atomic

      - name: Upload coverage to Coveralls
        if: matrix.go-version == '1.24' # Only upload from one Go version
        env:
          COVERALLS_TOKEN: ${{ secrets.COVERALLS_REPO_TOKEN }}
        run: |
          goveralls -coverprofile=coverage.out -service=github -repotoken $COVERALLS_TOKEN



================================================
File: .github/workflows/release.yml
================================================
name: Release and Generate Changelog

on:
  push:
    tags:
      - 'v*.*.*'

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up zip
        run: sudo apt-get update && sudo apt-get install -y zip

      - name: Gather release files
        run: |
          mkdir release
          cp -r src release/
          cp -r install release/
          [ -f project.lua ] && cp project.lua release/ || true
          [ -f almd-lock.lua ] && cp almd-lock.lua release/ || true
        shell: bash

      - name: Create distributable zip
        run: |
          cd release
          zip -r ../almd-release.zip .
        shell: bash

      - name: Get previous release tag
        id: prevtag
        run: |
          PREV_TAG=$(git tag --sort=-creatordate | grep '^v' | grep -v "${GITHUB_REF_NAME}" | head -n1)
          echo "prev_tag=$PREV_TAG" >> $GITHUB_OUTPUT
        shell: bash

      - name: Generate changelog
        id: changelog
        run: |
          if [ -n "${{ steps.prevtag.outputs.prev_tag }}" ]; then
            git log --pretty=format:'- %s (%an)' ${{ steps.prevtag.outputs.prev_tag }}..HEAD > changelog.md
          else
            git log --pretty=format:'- %s (%an)' > changelog.md
          fi
        shell: bash

      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Release ${{ github.ref_name }}
          body_path: changelog.md
          draft: false
          prerelease: false

      - name: Upload release asset (zip)
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./almd-release.zip
          asset_name: almd-release.zip
          asset_content_type: application/zip

      - name: Upload release asset (changelog)
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./changelog.md
          asset_name: changelog.md
          asset_content_type: text/markdown



================================================
File: .github/workflows/scorecard.yml
================================================
# This workflow uses actions that are not certified by GitHub. They are provided
# by a third-party and are governed by separate terms of service, privacy
# policy, and support documentation.

name: Scorecard supply-chain security
on:
  # For Branch-Protection check. Only the default branch is supported. See
  # https://github.com/ossf/scorecard/blob/main/docs/checks.md#branch-protection
  branch_protection_rule:
  # To guarantee Maintained check is occasionally updated. See
  # https://github.com/ossf/scorecard/blob/main/docs/checks.md#maintained
  schedule:
    - cron: '26 19 * * 2'
  push:
    branches: [ "main" ]

# Declare default permissions as read only.
permissions: read-all

jobs:
  analysis:
    name: Scorecard analysis
    runs-on: ubuntu-latest
    # `publish_results: true` only works when run from the default branch. conditional can be removed if disabled.
    if: github.event.repository.default_branch == github.ref_name || github.event_name == 'pull_request'
    permissions:
      # Needed to upload the results to code-scanning dashboard.
      security-events: write
      # Needed to publish results and get a badge (see publish_results below).
      id-token: write
      # Uncomment the permissions below if installing in a private repository.
      # contents: read
      # actions: read

    steps:
      - name: "Checkout code"
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false

      - name: "Run analysis"
        uses: ossf/scorecard-action@f49aabe0b5af0936a0987cfb85d86b75731b0186 # v2.4.1
        with:
          results_file: results.sarif
          results_format: sarif
          # (Optional) "write" PAT token. Uncomment the `repo_token` line below if:
          # - you want to enable the Branch-Protection check on a *public* repository, or
          # - you are installing Scorecard on a *private* repository
          # To create the PAT, follow the steps in https://github.com/ossf/scorecard-action?tab=readme-ov-file#authentication-with-fine-grained-pat-optional.
          # repo_token: ${{ secrets.SCORECARD_TOKEN }}

          # Public repositories:
          #   - Publish results to OpenSSF REST API for easy access by consumers
          #   - Allows the repository to include the Scorecard badge.
          #   - See https://github.com/ossf/scorecard-action#publishing-results.
          # For private repositories:
          #   - `publish_results` will always be set to `false`, regardless
          #     of the value entered here.
          publish_results: true

          # (Optional) Uncomment file_mode if you have a .gitattributes with files marked export-ignore
          # file_mode: git

      # Upload the results as artifacts (optional). Commenting out will disable uploads of run results in SARIF
      # format to the repository Actions tab.
      - name: "Upload artifact"
        uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # v4.6.1
        with:
          name: SARIF file
          path: results.sarif
          retention-days: 5

      # Upload the results to GitHub's code scanning dashboard (optional).
      # Commenting out will disable upload of results to your repo's Code Scanning dashboard
      - name: "Upload to code-scanning"
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: results.sarif



